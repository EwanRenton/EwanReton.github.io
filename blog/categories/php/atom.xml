<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | Ewan Reton]]></title>
  <link href="http://ewanreton.github.io/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://ewanreton.github.io/"/>
  <updated>2016-06-07T11:36:47+08:00</updated>
  <id>http://ewanreton.github.io/</id>
  <author>
    <name><![CDATA[Ewan Reton]]></name>
    <email><![CDATA[liukedi001@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[PHP设计模式(七)-装饰器模式]]></title>
    <link href="http://ewanreton.github.io/blog/2016/06/07/php-design-7/"/>
    <updated>2016-06-07T10:53:23+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/06/07/php-design-7</id>
    <content type="html"><![CDATA[<h1>1、模式定义</h1>

<p>装饰器模式能够从一个对象的外部动态地给对象添加功能。</p>

<p>通常给对象添加功能，要么直接修改对象添加相应的功能，要么派生对应的子类来扩展，抑或是使用对象组合的方式。显然，直接修改对应的类这种方式并不可取。在面向对象的设计中，我们也应该尽量使用对象组合，而不是对象继承来扩展和复用功能。装饰器模式就是基于对象组合的方式，可以很灵活的给对象添加所需要的功能。装饰器模式的本质就是动态组合。动态是手段，组合才是目的。</p>

<p>常见的使用示例：Web服务层 —— 为 REST 服务提供 JSON 和 XML 装饰器。</p>

<h1>2、UML类图</h1>

<p><img src="http://laravelacademy.org/wp-content/uploads/2015/12/decorator-design-pattern.png" alt="" /></p>

<h1>3、实例代码</h1>

<p>定义接口：</p>

<pre><code class="php RendererInterface.php">    &lt;?php

    namespace DesignPatterns\Structural\Decorator;

    /**
     * RendererInterface接口
     */
    interface RendererInterface
    {
        /**
         * render data
         *
         * @return mixed
         */
        public function renderData();
    }
</code></pre>

<pre><code class="php Webservice.php">    &lt;?php

    namespace DesignPatterns\Structural\Decorator;

    /**
     * Webservice类
     */
    class Webservice implements RendererInterface
    {
        /**
         * @var mixed
         */
        protected $data;

        /**
         * @param mixed $data
         */
        public function __construct($data)
        {
            $this-&gt;data = $data;
        }

        /**
         * @return string
         */
        public function renderData()
        {
            return $this-&gt;data;
        }
    }

个人感觉在这里没有必要实现RendererInterface接口，
实现这个接口过后就必须实现renderData方法，而这个方法仅仅是用来返回数据。
但是这个名字和后面装饰器的实现方法重名，很容易混乱。
这里如果不实现RendererInterface接口，将renderData()改为getData（）应该会好一些，至少程序没那么容易搞混。
</code></pre>

<p>装饰器抽象类：</p>

<pre><code class="php Decorator.php">    &lt;?php

    namespace DesignPatterns\Structural\Decorator;

    /**
     * 装饰器必须实现 RendererInterface 接口, 这是装饰器模式的主要特点，
     * 否则的话就不是装饰器而只是个包裹类
     */

    /**
     * Decorator类
     */
    abstract class Decorator implements RendererInterface
    {
        /**
         * @var RendererInterface
         */
        protected $wrapped;

        /**
         * 必须类型声明装饰组件以便在子类中可以调用renderData()方法
         *
         * @param RendererInterface $wrappable
         */
        public function __construct(RendererInterface $wrappable)
        {
            $this-&gt;wrapped = $wrappable;
        }
    }
</code></pre>

<pre><code class="php RenderInXml.php">    &lt;?php

    namespace DesignPatterns\Structural\Decorator;

    /**
     * RenderInXml类
     */
    class RenderInXml extends Decorator
    {
        /**
         * render data as XML
         *
         * @return mixed|string
         */
        public function renderData()
        {
            $output = $this-&gt;wrapped-&gt;renderData();

            // do some fancy conversion to xml from array ...

            $doc = new \DOMDocument();

            foreach ($output as $key =&gt; $val) {
                $doc-&gt;appendChild($doc-&gt;createElement($key, $val));
            }

            return $doc-&gt;saveXML();
        }
    }
</code></pre>

<pre><code class="php RenderInJson.php">    &lt;?php

    namespace DesignPatterns\Structural\Decorator;

    /**
     * RenderInJson类
     */
    class RenderInJson extends Decorator
    {
        /**
         * render data as JSON
         *
         * @return mixed|string
         */
        public function renderData()
        {
            $output = $this-&gt;wrapped-&gt;renderData();

            return json_encode($output);
        }
    }
</code></pre>

<h1>4、测试代码</h1>

<pre><code class="php">    &lt;?php

    namespace DesignPatterns\Structural\Decorator\Tests;

    use DesignPatterns\Structural\Decorator;

    /**
     * DecoratorTest 用于测试装饰器模式
     */
    class DecoratorTest extends \PHPUnit_Framework_TestCase
    {

        protected $service;

        protected function setUp()
        {
            $this-&gt;service = new Decorator\Webservice(array('foo' =&gt; 'bar'));//实例化 Webservice 类
        }

        public function testJsonDecorator()
        {
            // Wrap service with a JSON decorator for renderers
            $service = new Decorator\RenderInJson($this-&gt;service);//给实例化的类添加装饰器
            // Our Renderer will now output JSON instead of an array
            $this-&gt;assertEquals('{"foo":"bar"}', $service-&gt;renderData());
        }

        public function testXmlDecorator()
        {
            // Wrap service with a XML decorator for renderers
            $service = new Decorator\RenderInXml($this-&gt;service);
            // Our Renderer will now output XML instead of an array
            $xml = '&lt;?xml version="1.0"?&gt;&lt;foo&gt;bar&lt;/foo&gt;';
            $this-&gt;assertXmlStringEqualsXmlString($xml, $service-&gt;renderData());
        }

        /**
         * The first key-point of this pattern :
         */
        public function testDecoratorMustImplementsRenderer()
        {
            $className = 'DesignPatterns\Structural\Decorator\Decorator';
            $interfaceName = 'DesignPatterns\Structural\Decorator\RendererInterface';
            $this-&gt;assertTrue(is_subclass_of($className, $interfaceName));
        }

        /**
         * Second key-point of this pattern : the decorator is type-hinted
         *
         * @expectedException \PHPUnit_Framework_Error
         */
        public function testDecoratorTypeHinted()
        {
            if (version_compare(PHP_VERSION, '7', '&gt;=')) {
                throw new \PHPUnit_Framework_Error('Skip test for PHP 7', 0, __FILE__, __LINE__);
            }

            $this-&gt;getMockForAbstractClass('DesignPatterns\Structural\Decorator\Decorator', array(new \stdClass()));
        }

        /**
         * Second key-point of this pattern : the decorator is type-hinted
         *
         * @requires PHP 7
         * @expectedException TypeError
         */
        public function testDecoratorTypeHintedForPhp7()
        {
            $this-&gt;getMockForAbstractClass('DesignPatterns\Structural\Decorator\Decorator', array(new \stdClass()));
        }

        /**
         * The decorator implements and wraps the same interface
         */
        public function testDecoratorOnlyAcceptRenderer()
        {
            $mock = $this-&gt;getMock('DesignPatterns\Structural\Decorator\RendererInterface');
            $dec = $this-&gt;getMockForAbstractClass('DesignPatterns\Structural\Decorator\Decorator', array($mock));
            $this-&gt;assertNotNull($dec);
        }
    } 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP设计模式(六)-原型模式]]></title>
    <link href="http://ewanreton.github.io/blog/2016/06/07/php-design-6/"/>
    <updated>2016-06-07T10:22:51+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/06/07/php-design-6</id>
    <content type="html"><![CDATA[<h1>1、模式定义</h1>

<p>通过创建原型使用克隆方法实现对象创建而不是使用标准的<code>new</code> 方式。</p>

<h1>2、UML类图</h1>

<p><img src="http://laravelacademy.org/wp-content/uploads/2015/12/120b8c2b-9cad-44e8-a286-3347d32d57dd.png" alt="" /></p>

<h1>3、示例代码</h1>

<pre><code class="php BookPrototype.php">&lt;?php

    namespace DesignPatterns\Creational\Prototype;

    /**
     * BookPrototype类
     */
    abstract class BookPrototype
    {
        /**
         * @var string
         */
        protected $title;

        /**
         * @var string
         */
        protected $category;

        /**
         * @abstract
         * @return void
         */
        abstract public function __clone();

        /**
         * @return string
         */
        public function getTitle()
        {
            return $this-&gt;title;
        }

        /**
         * @param string $title
         */
        public function setTitle($title)
        {
            $this-&gt;title = $title;
        }
    }
</code></pre>

<pre><code class="php BarBookPrototype.php">    &lt;?php

    namespace DesignPatterns\Creational\Prototype;

    /**
     * BarBookPrototype类
     */
    class BarBookPrototype extends BookPrototype
    {
        /**
         * @var string
         */
        protected $category = 'Bar';

        /**
         * empty clone
         */
        public function __clone()
        {
        }
    }
</code></pre>

<pre><code class="php FooBookPrototype.php">    &lt;?php

    namespace DesignPatterns\Creational\Prototype;

    /**
     * FooBookPrototype类
     */
    class FooBookPrototype extends BookPrototype
    {
        protected $category = 'Foo';

        /**
         * empty clone
         */
        public function __clone()
        {
        }
    }
</code></pre>

<h1>4、测试代码</h1>

<pre><code class="php">    &lt;?php

    namespace DesignPatterns\Creational\Prototype\Tests;

    use DesignPatterns\Creational\Prototype\BookPrototype;
    use DesignPatterns\Creational\Prototype\FooBookPrototype;
    use DesignPatterns\Creational\Prototype\BarBookPrototype;

    /**
     * PrototypeTest tests the prototype pattern
     */
    class PrototypeTest extends \PHPUnit_Framework_TestCase
    {
        //实例化得到类的原型
         public function getPrototype(){
             return array(
                 array(new FooBookPrototype()),
                 array(new BarBookPrototype())
             );
         }

         /**
          * 克隆类
          * @dataProvider getPrototype
          */
         public function testCreation(BookPrototype $prototype)
         {
             $book = clone $prototype;
             $book-&gt;setTitle($book-&gt;getCategory().' Book');
             $this-&gt;assertInstanceOf('DesignPatterns\Creational\Prototype\BookPrototype', $book);
         }
    } 
</code></pre>

<h1>5、总结</h1>

<p>原型模式的主要思想是基于现有的对象克隆一个新的对象出来，一般是用对象内部提供的克隆方法，通过该方法返回一个对象的副本，这种创建对象的方式，相比我们之前说的几类创建型模式还是有区别的，之前的讲述的工厂方法模式与抽象工厂都是通过工厂封装具体的 new 操作的过程，返回一个新的对象，有的时候我们通过这样的创建工厂创建对象不值得，特别是以下的几个场景，可能使用原型模式更简单、效率更高：</p>

<ul>
<li>如果说我们的对象类型不是刚开始就能确定，而是在运行时确定的话，那么我们通过这个类型的对象克隆出一个新的类型更容易。</li>
<li>有的时候我们可能在实际的项目中需要一个对象在某个状态下的副本，这个前提很重要，这点怎么理解呢，例如有的时候我们需要对比一个对象经过处理后的状态和处理前的状态是否发生过改变，可能我们就需要在执行某段处理之前，克隆这个对象此时状态的副本，然后等执行后的状态进行相应的对比，这样的应用在项目中也是经常会出现的。</li>
<li>当我们处理的对象比较简单，并且对象之间的区别很小，可能只是很固定的几个属性不同的时候，使用原型模式更合适。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP设计模式(四)-数据库对象映射模式]]></title>
    <link href="http://ewanreton.github.io/blog/2016/06/06/php-design-4/"/>
    <updated>2016-06-06T11:24:26+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/06/06/php-design-4</id>
    <content type="html"><![CDATA[<h1>1、模式定义</h1>

<p>在了解数据映射模式之前，先了解下数据映射，它是在持久化数据存储层（通常是关系型数据库）和驻于内存的数据表现层之间进行双向数据传输的数据访问层。</p>

<!--more-->


<p>数据映射模式的目的是让持久化数据存储层、驻于内存的数据表现层、以及数据映射本身三者相互独立、互不依赖。这个数据访问层由一个或多个映射器（或者数据访问对象）组成，用于实现数据传输。通用的数据访问层可以处理不同的实体类型，而专用的则处理一个或几个。</p>

<p>数据映射模式的核心在于它的数据模型遵循单一职责原则（Single Responsibility Principle）, 这也是和 Active Record 模式的不同之处。最典型的数据映射模式例子就是数据库 ORM 模型 （Object Relational Mapper）。</p>

<p><strong>ha_cl表</strong>
<img src="http://www.poluoluo.com/jzxy/UploadFiles_333/201603/2016030519294690.png?20162310358" alt="" /></p>

<pre><code class="php Hacl.php">    &lt;?php
    namespace Baobab;
    class Hacl{
    public $id;
    public $haclname;
    public $haclcode;
    public $hacls;
    protected $db;
    function __construct($id){
    $this-&gt;db = new \Baobab\Database\Mysqli();
    $this-&gt;db-&gt;connect('127.0.0.1', 'root', '', 'test');
    $res = $this-&gt;db-&gt;query("select * from ha_cl where id = {$id}");
    $data = $res-&gt;fetch_assoc();
    $this-&gt;id = $data['ID'];
    $this-&gt;haclname = $data['ha_cl_name'];
    $this-&gt;haclcode = $data['ha_cl_code'];
    $this-&gt;hacls = $data['hacls'];
    }
    function __destruct(){
    $this-&gt;db-&gt;query("update ha_cl set
    ha_cl_code = '{$this-&gt;haclcode}',
    ha_cl_name = '{$this-&gt;haclname}',
    hacls = '{$this-&gt;hacls}'
    where ID = {$this-&gt;id}
    limit 1");
    }
    }
</code></pre>

<pre><code class="php Factory.php">    //工厂模式
    &lt;?php
    namespace Baobab;
    class Factory{
    static function getHacl($id){
    $key = 'user_'.$id;
    $user = \Baobab\Register::get($key);//表中id不同表示的是不同的对象
    if(!$user){
    $user = new \Baobab\Hacl($id);
    \Baobab\Register::set($key, $user);
    }
    return $user;
    }
    }
</code></pre>

<pre><code class="php Register.php">    &lt;?php
    namespace Baobab;
    class Register{
    protected static $objects;
    static function set($alias, $object){
    self::$objects[$alias] = $object;
    }
    static function _unset($alias) {
    unset(self::$objects[$alias]);
    }
    static function get($name) {
    return self::$objects[$name];
    }
    }
</code></pre>

<pre><code class="php index.php">    class Page{
    function index(){
    $hacl = Baobab\Factory::getHacl(13);
    $hacl-&gt;haclname = '测试名称';
    $this-&gt;test();
    echo 'ok';
    }
    function test(){
    $hacl = Baobab\Factory::getHacl(13);
    $hacl-&gt;hacls = '测试内容';
    }
    }
    $page = new Page();
    $page-&gt;index(); 
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP设计模式(三)-策略模式]]></title>
    <link href="http://ewanreton.github.io/blog/2016/06/06/php-design-3/"/>
    <updated>2016-06-06T10:32:22+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/06/06/php-design-3</id>
    <content type="html"><![CDATA[<blockquote><p>在之前学习了PHP设计模式中的工厂模式，单例模式，注册树模式，适配器模式。今天来学习一下策略模式。</p></blockquote>

<!--more-->


<h1>一、策略模式概念</h1>

<p>策略模式针对一组算法，将每一个算法封装到具有共同接口的独立的类中,此模式让算法的变化独立于使用算法的客户。从而让程序结构更灵活，具有更好的扩展性和维护性。</p>

<p>策略模式:定义了算法族,分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p>

<p>封装:把行为用接口封装起来，我们可以把那些经常变化的部分，从当前的类中单独取出来，用接口进行单独的封装。
互相替换:我们封装好了接口，通过指定不同的接口实现类进行算法的变化。</p>

<h1>二、策略模式结构图</h1>

<p><img src="http://www.phpddt.com/usr/uploads/2014/01/2390999757.jpg" alt="" /></p>

<h1>三、策略模式角色说明</h1>

<p> 抽象策略(Strategy）角色：定义所有支持的算法的公共接口。通常是以一个接口或抽象来实现。Context使用这个接口来调用其ConcreteStrategy定义的算法。</p>

<p>具体策略(ConcreteStrategy)角色：以Strategy接口实现某具体算法</p>

<p>环境(Context)角色：持有一个Strategy类的引用，用一个ConcreteStrategy对象来配置</p>

<h1>四、实例一</h1>

<p>比如说购物车系统，在给商品计算总价的时候，普通会员肯定是商品单价乘以数量，但是对中级会员提供8者折扣，对高级会员提供7折折扣，这种场景就可以使用策略模式实现：</p>

<pre><code class="php">/**
 * 策略模式实例
 * 
 */
//抽象策略角色《为接口或者抽象类，给具体策略类继承》
interface Strategy
{
    public function computePrice($price);
}

//具体策略角色-普通会员策略类
class GenernalMember implements Strategy
{
    public function computePrice($price)
    {
        return $price;
    }
}

//具体策略角色-中级会员策略类
class MiddleMember implements Strategy
{
    public function computePrice($price)
    {
        return $price * 0.8;
    }
}

//具体策略角色-高级会员策略类
class HignMember implements Strategy
{
    public function computePrice($price)
    {
        return $price * 0.7;
    }
}

//环境角色实现类
class Price 
{
    //具体策略对象
    private $strategyInstance;

    //构造函数
    public function __construct($instance)
    {
        $this-&gt;strategyInstance = $instance;
    }

    public function compute($price)
    {
        return $this-&gt;strategyInstance-&gt;computePrice($price);
    }
}

//客户端使用
$p = new Price(new HignMember());

$totalPrice = $p-&gt;compute(100);

echo $totalPrice; //70
</code></pre>

<h1>实例二</h1>

<p><img src="http://pic002.cnblogs.com/images/2012/152332/2012022715404617.png" alt="" /></p>

<p>我来解释下这个思维导图的过程：</p>

<p>1.Joe做了一套相当成功的模拟鸭子的游戏。设计了一个超类Duck,然后让各种鸭子继承这个类。</p>

<p>2.后来客户提出要让鸭子有飞的能力。所以Joe就在超类中加了个fly()方法，这样下面的子类都有飞行的行为。</p>

<p> 问题来了：</p>

<ul>
<li>原来Duck的子类中竟然有橡皮鸭，橡皮鸭是不会飞的。——Joe用重载的方式，把橡皮鸭的fly()方法设置为空.</li>
<li>覆盖fly()，我们看到了橡皮鸭的fly()里，没有任何代码，如果以后我们再添加别的不会飞的鸭子，那我么还要这么处理吗?——那么代码重复了!</li>
</ul>


<p>3.上面2的方式我们知道是有问题的，所以Joe想到把Duck做成接口，这样每个子类必须实现Duck里的方法。这样就保证每个鸭子都能根据自己的需要添加行为。</p>

<p>问题来了：</p>

<ul>
<li>产品经常处于更新中，规格也在不断的变化。导致每当有新鸭子的时候，Joe就要被迫检查一遍子类是否覆盖了fly()方法。——当你修改某个行为的时候，你必须得往下追踪并在每一个定义此行为的类中修改它。</li>
</ul>


<p>4.综合以上问题，Joe想到了把那些变化的部分从不变化的位置中抽出来。比如，我们对fly()行为，做了单独的接口FlyBehavior。如果鸭子想要飞行功能的时候，我们就让鸭子实现FlyBehavior.</p>

<p>5.深造:我们想让鸭子有不同的飞行功能，让它在运行时候做不同的飞行动作。让鸭子类实现接口，只能让鸭子有一种行为。</p>

<p>所以Joe，想到用组合的防止，当鸭子需要其他飞行功能要求的时候，我们可以用setBehavior()方式，指定性的飞行方式。</p>

<pre><code class="php">interface FlyBehavior{
    public function fly();
}

class FlyWithWings implements FlyBehavior{
    public function fly(){
        echo "Fly With Wings \n";
    }
}

class FlyWithNo implements FlyBehavior{
    public function fly(){
        echo "Fly With No Wings \n";
    }
}
class Duck{
    private $_flyBehavior;
    public function performFly(){
        $this-&gt;_flyBehavior-&gt;fly();
    }

    public function setFlyBehavior(FlyBehavior $behavior){
        $this-&gt;_flyBehavior = $behavior;
    }
}

class RubberDuck extends Duck{
}
// Test Case
$duck = new RubberDuck();

/*  想让鸭子用翅膀飞行 */
$duck-&gt;setFlyBehavior(new FlyWithWings());
$duck-&gt;performFly();            

/*  想让鸭子不用翅膀飞行 */
$duck-&gt;setFlyBehavior(new FlyWithNo());
$duck-&gt;performFly();
</code></pre>

<h1>五、策略模式的控制和反转</h1>

<p>使用策略模式可以实现Ioc，依赖倒置和控制反转</p>

<p>在原本的类中，存在一个A类中调用B类，则A类是依赖于B类的。</p>

<p>通过几个接口的设置和策略的解耦，就把依赖进行了反转，也就是我们在写A类的时候不需要去实现B类。</p>

<p>只有在最后执行的时候才进行绑定。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP设计模式(二)-适配器模式]]></title>
    <link href="http://ewanreton.github.io/blog/2016/06/04/php-design-2/"/>
    <updated>2016-06-04T12:21:09+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/06/04/php-design-2</id>
    <content type="html"><![CDATA[<h1>适配器模式</h1>

<ol>
<li>适配器模式，可将一个类的接口转换成客户希望的另外一个接口，使得原本不兼容的接口能够一起工作。通俗的理解就是将不同接口适配成统一的API接口。</li>
</ol>


<!--more-->


<ol>
<li>实际应用举例，PHP的数据库操作有mysql，mysqli，pdo3种，可以用适配器模式改成统一致的，类似的还有cache适配器，将memcache，redis，file，apc等不同的缓存函数，统一成一致的。</li>
</ol>


<p>角色：</p>

<ul>
<li>Target适配目标，该角色定义把其他类转换为何种接口，也就是我们的期望接口。</li>
<li>Adaptee被适配者，就是需要被适配的接口。</li>
<li>Adapter适配器，其他的两个角色都是已经存在的角色，而适配器角色是需要新建立的，它用来对Adaptee与Target接口进行适配。</li>
</ul>


<p>优势：</p>

<p>被适配者通过适配器完成对适配目标的适配，以达到对客户使用透明的目的。</p>

<pre><code class="php">//适配目标，规定的接口将被适配对象实现
interface IDatabase
{
    public function connect($host, $username, $password, $database);
    public function query($sql);
}
 
//适配器
class Mysql implements IDatabase
{
    protected $connect;
 
    public function connect($host, $username, $password, $database)
    {
        $connect = mysql_connect($host, $username, $password);
        mysql_select_db($database, $connect);
        $this-&gt;connect = $connect;
        //...
    }
 
    public function query($sql)
    {
        //...
    }
}
 
//适配器
class Postgresql implements IDatabase
{
    protected $connect;
 
    public function connect($host, $username, $password, $database)
    {
        $this-&gt;connect = pg_connect("host=$host dbname=$database user=$username password=$password");
        //...
    }
 
    public function query($sql)
    {
        //...
    }
}
 
 
//客户端使用
$client = new Postgresql();
$client-&gt;query($sql);
</code></pre>
]]></content>
  </entry>
  
</feed>
