<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | Ewan Reton]]></title>
  <link href="http://ewanreton.github.io/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://ewanreton.github.io/"/>
  <updated>2016-05-16T16:02:56+08:00</updated>
  <id>http://ewanreton.github.io/</id>
  <author>
    <name><![CDATA[Ewan Reton]]></name>
    <email><![CDATA[liukedi001@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[QQ登录Demo]]></title>
    <link href="http://ewanreton.github.io/blog/2016/05/15/qq-login/"/>
    <updated>2016-05-15T16:12:15+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/05/15/qq-login</id>
    <content type="html"><![CDATA[<blockquote><p>今天完成了一个QQ登录的小Deom</p></blockquote>

<h1>前置条件</h1>

<ul>
<li>一个QQ号</li>
<li>一台公网通过域名可访问的web服务器</li>
</ul>


<!--more-->


<h1>申请AppID和AppKey</h1>

<p><a href="http://connect.qq.com/">QQ开放平台</a></p>

<p>如果是第一次登录，会跳转到管理中心，应用开发者注册
<img src="http://d.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=b43ea01c0d46f21fcd345e56c61f1a5d/7acb0a46f21fbe0908972df36c600c338644ad08.jpg?referer=6f234af490dda144831e58820b06&amp;x=.jpg" alt="开发者注册" />
注册后悔跳转到管理中心，点击创建应用</p>

<p><img src="http://c.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=7ab420c84634970a4373102aa5f1a0f5/fc1f4134970a304ef778481dd6c8a786c8175cfb.jpg?referer=ebbc6b2a5566d016270eaa189c99&amp;x=.jpg" alt="创建应用" />
回调地址，可以和上面一样，在开发的时候再修改。
<img src="http://f.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=f47f75cf902bd40746c7d3f84bb2ef6c/aa18972bd40735fa1b96a55e99510fb30e2408f7.jpg?referer=8ed677a03e12b31b9e7bf91968ae&amp;x=.jpg" alt="验证" />
将下面这段代码，复制到服务器首页<code>&lt;head&gt;</code>标签中。
<code>html
&lt;meta property="qc:admins" content="43216566776571625476636" /&gt;
</code></p>

<h1>添加测试回调地址</h1>

<p>在QQ开放平台应用详情中，选择信息管理，</p>

<p>在回调地址中添加</p>

<p><img src="http://g.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=2bafae5c4010b912bbc1f6fbf3c68d3e/738b4710b912c8fc25701f2afb039245d7882152.jpg?referer=37adaf2785025aaf8a254afb8f30&amp;x=.jpg" alt="添加回调地址" />
其中的callback.php可以自定义。</p>

<p>记得保存之前需要验证。</p>

<h1>引入官方SDK</h1>

<p><a href="http://wiki.connect.qq.com/">官方SDK</a></p>

<p>找到PHP下载（有能力可以自己手工开发，造车轮。）</p>

<p>放到站点根目录</p>

<h1>SDK参数配置</h1>

<p>访问<code>http://localhost/Connect2.1/install.php</code>
<img src="http://a.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=b155c91931d3d539c53d0fc60abc986d/14ce36d3d539b600424ce650ee50352ac75cb753.jpg?referer=0353883031d12f2e97129a50f131&amp;x=.jpg" alt="参数配置" />
配置成功后,保留API下的文件，其他的都可删除。</p>

<h1>SDK解读</h1>

<p><img src="http://g.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=440c3587322ac65c63056676cbc9c32c/e850352ac65c10382dc82725b5119313b17e89a7.jpg?referer=314909b58235e5ddc93b91eff77d&amp;x=.jpg" alt="" />
<img src="http://b.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=4c5e0d1fa086c9170c03523cf90601f2/d0c8a786c9177f3ebe9d15ea77cf3bc79e3d56a8.jpg?referer=4ebf08d032fae6cd55a39f519266&amp;x=.jpg" alt="" />
<img src="http://h.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=327017c44e540923ae69637ba263a034/ca1349540923dd54e98f4e8fd609b3de9d82485d.jpg?referer=cd4a9bc7be12c8fcede4c2fda833&amp;x=.jpg" alt="" />
<img src="http://a.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=22750c750bf431adb8d2433c7b0ddd92/d1a20cf431adcbefe6cb97e1abaf2edda2cc9f5e.jpg?referer=bd373c299e25bc31724a35a8d934&amp;x=.jpg" alt="" />
<img src="http://f.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=3ede9315d262853596e0d224a0d407fb/4ec2d5628535e5dd429f4c3871c6a7efcf1b62a2.jpg?referer=bc5660e9b63533faaca1a71ece60&amp;x=.jpg" alt="" />
<img src="http://b.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=9a446d86ff1986184547ef817ad65f4e/b151f8198618367af3eb973a29738bd4b21ce5f3.jpg?referer=7862fb405eee3d6d7bd1b3fb4391&amp;x=.jpg" alt="" />
<img src="http://g.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=f77b76cf902bd40746c7d3f84bb2ef6c/aa18972bd40735fa1892a65e99510fb30e2408f3.jpg?referer=8dd274a03e12b31b9e7bf9196892&amp;x=.jpg" alt="" />
<img src="http://a.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=4d470c1fa086c9170c03523cf90601f2/d0c8a786c9177f3ebf8414ea77cf3bc79e3d56a1.jpg?referer=4fa609d032fae6cd55a39f51927f&amp;x=.jpg" alt="" /></p>

<h1>将SDK整合到web中</h1>

<p>Connect2.1
放在同级目录下</p>

<pre><code class="php index.php">&lt;?php
require_once "Connect2.1/qqConnectAPI.php";
?&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
      &lt;meta charset="utf-8"&gt;
      &lt;title&gt;&lt;/title&gt;
  &lt;/heda&gt;
    &lt;body&gt;
        &lt;?php if(!isset($_COOKIE['qq_accesstokebn'])||!isset($_COOKIE['qq_openid'])){?&gt;
        &lt;a href="qqlogin.php"&gt;登录QQ&lt;/a&gt;
        &lt;?php }else{?&gt;
          &lt;a href="qqlogout.php"&gt;退出QQ&lt;/a&gt;
          &lt;?php
            $qc = new QC($_COOKIE['qq_accesstokebn'],$_COOKIE['qq_openid']);
            $userinfo =$qc-&gt;get_user_info();
            print_r($userinfo);
                }
          ?&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="php qqlogin.php">&lt;?php
  require_once 'Connect2.1/qqConnectAPI.php';
  //访问QQ页面
  $oauth = new Oauth();
  $oauth-&gt;qq_login();
 ?&gt;
</code></pre>

<pre><code class="php qqlogout.php">&lt;?php
  setcookie('qq_accesstokebn',null);
  setcookie('qq_openid',null);
  header("Location:index.php");
?&gt;
</code></pre>

<pre><code class="php callback.php">&lt;?php
require_once 'Connect2.1/qqConnectAPI.php';
  //echo $_GET['code'];
  //请求accesstoken

$oauth = new Oauth();
$accesstoken = $oauth-&gt;qq_callback();
$openid = $oauth-&gt;get_openid();
setcookie("qq_accesstokebn",$accesstoken,time()+86400);
setcookie("qq_openid",$openid,time()+86400);
header("Location:index.php")
?&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memcache]]></title>
    <link href="http://ewanreton.github.io/blog/2016/05/14/memcache/"/>
    <updated>2016-05-14T20:08:26+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/05/14/memcache</id>
    <content type="html"><![CDATA[<h1>什么是Memcache</h1>

<p>Memcache通过缓存服务器信息的方式来加速服务器处理能力的系统。Memcache分配一块服务器上的内存来缓存一段特定时间之内的最近的查询数据。一旦某个数据被再次请求，那么Memcache就直接从内存中返回这个数据，而不是从数据库中，所以这将会加速查询速度。</p>

<!--more-->


<h1>Memcache使用场景</h1>

<ul>
<li>非持久化存储：对数据存储要求不高</li>
<li>分布式存储：不适合单机（对内存消耗很大）</li>
<li>ke/value存储：格式简单，不支持List，Array数据格式

<h1>Memcache服务端的安装</h1></li>
<li>编译安装 Libevent Memcache</li>
<li>依赖管理工具 yum apt-get</li>
<li>Memcache 和Memcached

<ul>
<li>Memcached 是Memcache的升级版本 推荐使用
<code>sudo apt-get install memcached</code></li>
</ul>
</li>
</ul>


<p>安装完Memcache服务端以后，我们需要启动该服务：</p>

<p><code>memcached -d -m 128 -p 11211 -u root</code>
使用<code>ps -ef |grep memcach</code>查看是否启动
这里需要说明一下memcached服务的启动参数：</p>

<ul>
<li>-p 监听的端口</li>
<li>-l 连接的IP地址, 默认是本机</li>
<li>-d start 启动memcached服务

<ul>
<li>-d restart 重起memcached服务</li>
<li>-d stop|shutdown 关闭正在运行的memcached服务</li>
<li>-d install 安装memcached服务</li>
<li>-d uninstall 卸载memcached服务</li>
</ul>
</li>
<li>-u 以的身份运行 (仅在以root运行的时候有效)</li>
<li>-m 最大内存使用，单位MB。默认64MB</li>
<li>-M 内存耗尽时返回错误，而不是删除项</li>
<li>-c 最大同时连接数，默认是1024</li>
<li>-f 块大小增长因子，默认是1.25-n 最小分配空间，key+value+flags默认是48</li>
<li>-h 显示帮助

<h1>Memcache客户端的安装</h1></li>
<li>安装Libmemcached</li>
<li>为PHP安装memcached扩展
<code>sudo apt-get install php5-memcache</code>
安装完以后我们需要在php.ini里进行简单的配置,打开/etc/php5/apache2/php.ini文件在末尾添加如下内容：
```php
[Memcache]</li>
</ul>


<p>; 一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，
; 它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。</p>

<p>; 是否在遇到错误时透明地向其他服务器进行故障转移。
memcache.allow_failover = On</p>

<p>; 接受和发送数据时最多尝试多少个服务器，只在打开memcache.allow_failover时有效。memcache.max_failover_attempts = 20</p>

<p>; 数据将按照此值设定的块大小进行转移。此值越小所需的额外网络传输越多。
; 如果发现无法解释的速度降低，可以尝试将此值增加到32768。
memcache.chunk_size = 8192</p>

<p>; 连接到memcached服务器时使用的默认TCP端口。
memcache.default_port = 11211</p>

<p>; 控制将key映射到server的策略。默认值”standard”表示使用先前版本的老hash策略。
; 设为”consistent”可以允许在连接池中添加/删除服务器时不必重新计算key与server之间的映射关系。
;memcache.hash_strategy = “standard”; 控制将key映射到server的散列函数。默认值”crc32″使用CRC32算法，而”fnv”则表示使用FNV-1a算法。
; FNV-1a比CRC32速度稍低，但是散列效果更好。
;memcache.hash_function = “crc32″
```</p>

<p>保存<code>php.ini</code>,执行<code>service apache2 restart</code>重启Apache。使用<code>php -m |grep memchched</code>查看是否安装成功</p>

<h1>Memcached 常见操作</h1>

<pre><code class="php">&lt;?php
$m = new Memcached();
$array=array(
  array('127.0.0.1',11211),

);
$m-&gt;addServers($array); //添加服务器 添加多条为addServers 一条为 addServer（“127.0.0.1”，11211）；
// // echo "11";
// $info=$m-&gt;getStats();
// print_r($info);
//数据类操作
//add
$m-&gt;add("mkey","mvalue",600);//key value time
$m-&gt;add("mkey","mvalue2",600);//两次赋值不会改变它的值
$m-&gt;replace("mkey","mvalue3",600);//替换
echo $m-&gt;get("mkey");
$m-&gt;set("mkey","mvalue",600);//常用，如果不存在mkey则创建，如果存在则覆盖
$m-&gt;delete("mkey");//删除
$m-&gt;flush();//清空memcache中的所有缓存
$m-&gt;set("num",5,0);
$m-&gt;increment("num",5);//每次刷新num+5
$m-&gt;decrement("num",5);//每次刷新num-5
?&gt;
</code></pre>

<pre><code class="php">&lt;?php
  $m = new Memcached();
  $array=array(
    array("127.0.0.1",11211),
  );
  $m-&gt;addServers($array);
  $data=array(
    "key" =&gt; "value",
    "key2" =&gt;"value2",

  );
  $m-&gt;setMulti($data,0); //一次设置多个值
 $result=  $m-&gt;getMulti(array("key","key2"));//一次获取多个值
 print_r($result);
 $m-&gt;deleteMulti(array("key","key2"));//一次删除多个值
 $m-&gt;getResultCode();//获取上次操作返回值
 $m-&gt;getResultMessage();//获取上次操作的信息
?&gt;
</code></pre>

<p><a href="http://php.net/manual/zh/book.memcached.php">官方说明文档</a></p>

<h1>项目中使用Memcached</h1>

<ul>
<li>即时生成缓存　

<ul>
<li>类似于新闻详情页，第一个人来了生成缓存，第二个人再来直接读缓存</li>
</ul>
</li>
<li>提前生成缓存

<ul>
<li>适合高访问量</li>
</ul>
</li>
<li>永久缓存

<ul>
<li>关于我们 这种基本不变的网页</li>
</ul>
</li>
</ul>


<h1>注意事项</h1>

<ul>
<li>不要在单机模式中使用Memcached</li>
<li>不要在Memcached保存重要数据。掉电会丢失。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP性能优化初识]]></title>
    <link href="http://ewanreton.github.io/blog/2016/05/04/php-xing-neng-you-hua/"/>
    <updated>2016-05-04T22:46:21+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/05/04/php-xing-neng-you-hua</id>
    <content type="html"><![CDATA[<blockquote><p>PHP性能优化</p></blockquote>

<!--more-->


<h1>一、PHP性能优化问题解析</h1>

<p>PHP的性能问题，占整体项目性能问题的比例不足50%，所以在考虑性能优化项目的时候，不要局限于仅优化PHP。</p>

<p>PHP的性能优化问题的解决方向（困难度从容易到简单）</p>

<pre><code>PHP语言级的性能优化
PHP周边问题的性能优化（开发环境等）
PHP语言自身分析、优化（底层C）
</code></pre>

<h2>压力测试工具简介</h2>

<p><strong>Apache Benchmark（ab）</strong></p>

<p>简介</p>

<pre><code>ab是由Apache提供的压力测试软件。安装Apache服务器时会自带该压测软件。
</code></pre>

<p>如何使用</p>

<pre><code>./ab -n1000 -c100 http://www.baidu.com （目标网址）
-n 请求数
-c 并发数
url 目标压测地址
</code></pre>

<p>结果分析</p>

<pre><code>主要看
Request per second 每秒接受的请求数
Time per request   一个请求的耗时
</code></pre>

<h1>二、PHP语言级的优化</h1>

<p><strong>优化点：少写代码，多用PHP自身能力,多使用PHP内置的函数，变量，常量</strong></p>

<p><strong>性能问题：自写代码冗余较多，可读性不佳，并且性能低</strong></p>

<p>为什么性能低？</p>

<pre><code>我们自己写的代码每次需要编译解析成底层语言，每一次请求都会处理一遍开销很大。
</code></pre>

<hr />

<p><strong>PHP内置函数的性能优劣</strong></p>

<p>情况描述：</p>

<pre><code>PHP内置函数之间依然存在着快慢差异
</code></pre>

<p>多去了解PHP内置函数的时间复杂度</p>

<p>举例
<code>php
&lt;?php
    $start=current_time();
    $i=0;
    $arr=range(1,200000);
    while($i&lt;200000){
        ++$i;
        //isset($arr[$i]); //测试结果50多ms
        array_key_exists($i,$arr); //测试结果80多ms
    }
    $end=current_time();
    echo "Lost Time:".number_format($end-$start,3)*1000;
    echo "\n";
    /**
     *返回一个微秒级别的时间戳
     */
    function current_time(){
        list($usec,$sec)=explode("",microtime());
        return ((float)$usce+(float)$sec);
    }
?&gt;
</code>
测试结果说明isset比array_key_exists函数更优化。</p>

<hr />

<p><strong>减少PHP魔法函数的使用</strong></p>

<p>情况描述：</p>

<pre><code>PHP提供的魔法函数性能不佳
</code></pre>

<p>举例
<code>php
&lt;?php
class test{
    private $var="123";
    public function __get($varname){
        return $this-&gt;var;
    }
}
$i=0;
while($i&lt;10000-){
    $i++;
    $test=new test();
    $test-&gt;var;
}//大概80ms
?&gt;
</code></p>

<pre><code class="php">&lt;?php
class test{
    public $var="123";
    //public function __get($varname){
        //return $this-&gt;var;
    //}
}
$i=0;
while($i&lt;100000){
    $i++;
    $test=new test();
    $test-&gt;var;
}//大概50ms
?&gt;
</code></pre>

<p>不使用魔法函数，性能更优化。</p>

<p>PS：</p>

<pre><code>在Linux中可以使用 time php test.php
会输出三个时间，主要关注user为执行时间
</code></pre>

<hr />

<p><strong>产生额外开销的错误抑制符@</strong></p>

<p>情况描述：</p>

<pre><code>@的实际逻辑是在代码开始前结束后增加Opcode 忽略报错。
在@这行前加入Opcode忽略报错，又在这行结束后再加入Opcode，恢复报错。
</code></pre>

<pre><code class="php">&lt;?php
    file_get_contents("XXX");

?&gt;
</code></pre>

<p>用VLD扩展看Opcode代码：</p>

<pre><code>php -dvld.active=1 -dvld.execute=0 at.php //我们只看代码不执行

有三行代码
加上@符号后
有五行代码
</code></pre>

<p>建议不要使用错误抑制符@，
多使用try catch</p>

<hr />

<p><strong>合理使用内存</strong></p>

<p>情况描述：</p>

<pre><code>PHP有内存回收机制保底，但也要小心使用内存。
</code></pre>

<p>利用unset（）及时释放不适用的内存（注：unset（）出现注销不掉的情况）</p>

<hr />

<p><strong>尽量少的使用正则表达式</strong></p>

<p>情况描述：</p>

<pre><code>正则表达式的回溯开销较大。
</code></pre>

<hr />

<p><strong>避免在循环内做运算</strong></p>

<p>情况描述:</p>

<pre><code>循环内的计算式将会被重复计算
</code></pre>

<pre><code class="php">&lt;?php
    $str="Hello World!"
    for($i=0;$i&lt;strlen($str);$i++){//每次循环都会计算这个字符串的长度
        //do something
    }
?&gt;
</code></pre>

<p>改进：</p>

<pre><code class="php">&lt;?php
    $str="Hello World!"
    $strlen=strlen($str)
    for($i=0;$i&lt;$strlen;$i++){
        //do something
    }
?&gt;
</code></pre>

<hr />

<p><strong>减少计算密集型业务</strong></p>

<p>情况描述：</p>

<pre><code>PHP的语言特性决定了PHP不适合密集型运算的场景。
因为PHP是基于C语言的，所以在处理大型运算的时候开销是比C大很多的。
</code></pre>

<p>适合的场景：</p>

<pre><code>衔接Webserver与后端服务，UI呈现。
</code></pre>

<hr />

<p><strong>务必使用带引号字符串做键值</strong></p>

<p>情况描述：</p>

<pre><code>PHP会将没有引号的键值当做常量，产生查找常量的开销。
</code></pre>

<hr />

<h1>三、PHP周边问题的性能优化</h1>

<p><strong>Linux 运行环境</strong></p>

<p><strong>减少文件类的操作</strong></p>

<p>常见PHP场景的开销次序：</p>

<pre><code>读写内存&lt;&lt;读写数据库（数据库有内存缓存）&lt;读写磁盘&lt;读写网络数据（网络延迟）
</code></pre>

<hr />

<p><strong>优化网络请求</strong></p>

<p>可能的问题：
    1. 对方接口的不确定因素
    2. 网络稳定性</p>

<p>优化：</p>

<pre><code>1. 设置超时时间
    连接超时（２００ｍｓ）
    读超时（８００ｍｓ）
    写超时（５００ｍｓ）
２.　串行请求并行化
    使用curl_multi_*() //取决于最长的连接时间所以不推荐
    使用swoole扩展　　
</code></pre>

<hr />

<p><strong>压缩PHP接口输出</strong></p>

<p>使用Gzip压缩即可</p>

<p>优点：</p>

<pre><code>利于我们的数据输出，Client能更快获取数据
</code></pre>

<p>缺点：</p>

<pre><code>产生cpu额外开销
</code></pre>

<p>可以考虑当数据大于多少时再使用压缩来优化。</p>

<hr />

<p><strong>缓存重复计算的内容</strong></p>

<p>什么情况下：</p>

<pre><code>多次请求，内容不变 //使用模板渲染缓存 如smarty 开启caching
</code></pre>

<hr />

<p><strong>重叠时间窗口思想和旁路方案</strong></p>

<pre><code>在几个任务不强依赖前一个任务的输出或者返回时。可以在上一个任务没完成时就执行下一个任务
</code></pre>

<hr />

<h1>四、PHP性能分析</h1>

<p><strong>用XHPorf进行PHP性能问题的具体分析</strong></p>

<p>XHPorf：源自Facebook的PHP性能优化工具
其他工具：</p>

<pre><code>ab -压力测试
vld -opcode 代码分析
</code></pre>

<p><a href="http://www.imooc.com/video/4275">here</a></p>

<h1>五、PHP性能瓶颈究极办法</h1>

<p>Opcode Cache ： PHP扩展APC，memcache</p>

<p>通过PHP扩展代替原PHP代码中高频逻辑</p>

<p>Runtime优化： HHVM</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP高性能日志SeasLog]]></title>
    <link href="http://ewanreton.github.io/blog/2016/04/29/php-seaslog/"/>
    <updated>2016-04-29T09:59:55+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/04/29/php-seaslog</id>
    <content type="html"><![CDATA[<blockquote><p>PHP高性能日志SeasLog</p></blockquote>

<h1>一、什么是SeasLog</h1>

<p>SeasLog是一个C语言编写的PHP扩展，提供一组规范标准的功能函数，在PHP项目中方便、规范、高效地写日志，以及快速地读取和查询日志。</p>

<!--more-->


<h1>二、为什么需要日志系统</h1>

<ol>
<li>了解系统运行情况</li>
<li>记录用户操作信息</li>
<li>收集需要</li>
</ol>


<h1>三、为什么选择SeasLog</h1>

<ol>
<li>高性能 带有缓冲池功能。</li>
<li>无需配置</li>
<li>功能完善，使用简单

<h1>四、SeasLog安装</h1>

<p> 到<a href="http://pecl.php.net/">pecl</a>搜索seaslog并下载
 解压后
 可自行编译。
<code>
$ cd seaslog //进到解压目录
$ phpize
$ ./configure --with-php-config=/path/to/php-config //path to 为你的PHP安装目录
$ make &amp;&amp; make install
当然，使用PECL管理工具会更方便：
$ pecl install seaslog
</code></p></li>
</ol>


<h2>seaslog.ini的配置</h2>

<pre><code>; configuration for php SeasLog module 
extension = seaslog.so 
seaslog.default_basepath = /log/seaslog-test    ;默认log根目录 
seaslog.default_logger = default                ;默认logger目录 
seaslog.disting_type = 1                            ;是否以type分文件 1是 0否(默认) 
seaslog.disting_by_hour = 1                      ;是否每小时划分一个文件 1是 0否(默认) 
seaslog.use_buffer = 1                              ;是否启用buffer 1是 0否(默认) 
seaslog.buffer_size = 100                         ;buffer中缓冲数量 默认0(不使用buffer_size) 
seaslog.level = 0                                       ;记录日志级别 默认0(所有日志)
</code></pre>

<p><strong>需要将这里面的数据写到php.ini中去</strong></p>

<pre><code>seaslog.disting_type = 1 开启以type分文件，即log文件区分info\warn\erro
seaslog.disting_by_hour = 1 开启每小时划分一个文件
seaslog.use_buffer = 1 开启buffer。默认关闭。当开启此项时，日志预存于内存，当请求结束时(或异常退出时)一次写入文件。
seaslog.buffer_size = 100 设置缓冲数量为100. 默认为0,即无缓冲数量限制.当buffer_size大于0时,缓冲量达到该值则写一次文件.
seaslog.level = 3 记录的日志级别.默认为0,即所有日志均记录。当level为1时,关注debug以上级别(包括debug)，以此类推。level大于8时，所有日志均不记录。
</code></pre>

<h2>默认常量有哪些</h2>

<p>遵循PSR-3标准，SeasLog 共将日志分成8个级别</p>

<pre><code>SEASLOG_DEBUG "debug"
SEASLOG_INFO "info"
SEASLOG_NOTICE "notice"
SEASLOG_WARNING "warning"
SEASLOG_ERROR "error"
SEASLOG_CRITICAL "critical"
SEASLOG_ALERT "alert"
SEASLOG_EMERGENCY "emergency"
</code></pre>

<h2>都提供哪些方法</h2>

<pre><code>
&lt;?php 
/** 
 * @author neeke@php.net 云智慧 
 */ 

class SeasLog 
{ 
    public function __construct() 
    { 
        #SeasLog init 
    } 

    public function __destruct() 
    { 
        #SeasLog distroy 
    } 

    /** 
     * 设置basePath 
     * @param $basePath 
     * @return bool 
     */ 
    static public function setBasePath($basePath) 
    { 
        return TRUE; 
    } 

    /** 
     * 获取basePath 
     * @return string 
     */ 
    static public function getBasePath() 
    { 
        return 'the base_path'; 
    } 

    /** 
     * 设置模块目录 
     * @param $module 
     * @return bool 
     */ 
    static public function setLogger($module) 
    { 
        return TRUE; 
    } 

    /** 
     * 获取最后一次设置的模块目录 
     * @return string 
     */ 
    static public function getLastLogger() 
    { 
        return 'the lastLogger'; 
    } 

    /** 
     * 统计所有类型（或单个类型）行数 
     * @param string $level 
     * @param string $log_path 
     * @param null $key_word 
     * @return array | long 
     */ 
    static public function analyzerCount($level = 'all',$log_path = '*',$key_word = NULL) 
    { 
        return array(); 
    } 

    /** 
     * 以数组形式，快速取出某类型log的各行详情 
     * @param $level 
     * @param string $log_path 
     * @param null $key_word 
     * @param int $start 
     * @param int $limit 
     * @return array 
     */ 
    static public function analyzerDetail($level = SEASLOG_INFO,$log_path = '*',$key_word = NULL, $start = 1,$limit = 20) 
    { 
        return array(); 
    } 

    /** 
     * 获得当前日志buffer中的内容 
     * @return array 
     */ 
    static public function getBuffer() 
    { 
        return array(); 
    } 

    /** 
     * 记录debug日志 
     * @param $message 
     * @param array $content 
     * @param string $module 
     */ 
    static public function debug($message,array $content = array(),$module = '') 
    { 
        #$level = SEASLOG_DEBUG 
    } 

    /** 
     * 记录info日志 
     * @param $message 
     * @param array $content 
     * @param string $module 
     */ 
    static public function info($message,array $content = array(),$module = '') 
    { 
        #$level = SEASLOG_INFO 
    } 

    /** 
     * 记录notice日志 
     * @param $message 
     * @param array $content 
     * @param string $module 
     */ 
    static public function notice($message,array $content = array(),$module = '') 
    { 
        #$level = SEASLOG_NOTICE 
    } 

    /** 
     * 记录warning日志 
     * @param $message 
     * @param array $content 
     * @param string $module 
     */ 
    static public function warning($message,array $content = array(),$module = '') 
    { 
        #$level = SEASLOG_WARNING 
    } 

    /** 
     * 记录error日志 
     * @param $message 
     * @param array $content 
     * @param string $module 
     */ 
    static public function error($message,array $content = array(),$module = '') 
    { 
        #$level = SEASLOG_ERROR 
    } 

    /** 
     * 记录critical日志 
     * @param $message 
     * @param array $content 
     * @param string $module 
     */ 
    static public function critical($message,array $content = array(),$module = '') 
    { 
        #$level = SEASLOG_CRITICAL 
    } 

    /** 
     * 记录alert日志 
     * @param $message 
     * @param array $content 
     * @param string $module 
     */ 
    static public function alert($message,array $content = array(),$module = '') 
    { 
        #$level = SEASLOG_ALERT 
    } 

    /** 
     * 记录emergency日志 
     * @param $message 
     * @param array $content 
     * @param string $module 
     */ 
    static public function emergency($message,array $content = array(),$module = '') 
    { 
        #$level = SEASLOG_EMERGENCY 
    } 

    /** 
     * 通用日志方法 
     * @param $level 
     * @param $message 
     * @param array $content 
     * @param string $module 
     */ 
    static public function log($level,$message,array $content = array(),$module = '') 
    { 

    } 
} 
</code></pre>

<h2>在项目中如何使用</h2>

<blockquote><p>获取与设置basePatn</p></blockquote>

<pre><code>/**
 *静态方法可以不实例化直接使用
 *
 */
$basePath_1 = SeasLog::getBasePath(); 

SeasLog::setBasePath('/log/base_test'); 
$basePath_2 = SeasLog::getBasePath(); 

var_dump($basePath_1,$basePath_2); 

/* 
string(19) "/log/seaslog-ciogao" 
string(14) "/log/base_test" 
*/ 
</code></pre>

<p>直接使用 SeasLog::getBasePath()，将获取php.ini(seaslog.ini)中设置的seaslog.default_basepath 的值。</p>

<p>使用 SeasLog::getBasePath() 函数，将改变 seaslog_get_basepath() 的取值。</p>

<blockquote><p>设置logger与获取lastLogger</p></blockquote>

<pre><code>$lastLogger_1 = SeasLog::getLastLogger(); 

SeasLog::setLogger('testModule/app1'); 
$lastLogger_2 = SeasLog::getLastLogger(); 

var_dump($lastLogger_1,$lastLogger_2); 
/* 
string(7) "default" 
string(15) "testModule/app1" 
*/ 
</code></pre>

<p>与basePath相类似的，
直接使用 SeasLog::getLastLogger()，将获取php.ini(seaslog.ini)中设置的seaslog.default_logger 的值。</p>

<p>使用 SeasLog::setLogger() 函数，将改变 SeasLog::getLastLogger() 的取值。</p>

<h2>SeasLog Logger的使用</h2>

<blockquote><p>获取与设置basePath</p></blockquote>

<pre><code>$basePath_1 = SeasLog::getBasePath();

SeasLog::setBasePath('/log/base_test');
$basePath_2 = SeasLog::getBasePath();

var_dump($basePath_1,$basePath_2);

/*
string(19) "/log/seaslog-ciogao"
string(14) "/log/base_test"
*/
</code></pre>

<p>直接使用 SeasLog::getBasePath()，将获取php.ini(seaslog.ini)中设置的 seaslog.default_basepath 的值。</p>

<p>使用 SeasLog::setBasePath() 函数，将改变 SeasLog::getBasePath() 的取值。</p>

<blockquote><p>设置logger与获取lastLogger</p></blockquote>

<pre><code>$lastLogger_1 = SeasLog::getLastLogger();

SeasLog::setLogger('testModule/app1');
$lastLogger_2 = SeasLog::getLastLogger();

var_dump($lastLogger_1,$lastLogger_2);
/*
string(7) "default"
string(15) "testModule/app1"
*/
</code></pre>

<p>与basePath相类似的，</p>

<p>直接使用 SeasLog::getLastLogger()，将获取php.ini(seaslog.ini)中设置的 seaslog.default_logger 的值。</p>

<p>使用 SeasLog::setLogger() 函数，将改变 SeasLog::getLastLogger() 的取值。
快速写入log</p>

<p>上面已经设置过了basePath与logger，于是log记录的目录已经产生了，</p>

<p>log记录目录 = basePath / logger / {fileName}.log log文件名，以 年月日 分文件，如今天是2014年02月18日期，那么 {fileName} = 20140218;
还记得 php.ini 中设置的 seaslog.disting_type 吗？</p>

<p>默认的 seaslog.disting_type = 0，如果今天我使用了 SeasLog ，那么将产生最终的log文件：</p>

<p>*　LogFile = basePath / logger / 20140218.log
如果 seaslog.disting_type = 1，则最终的log文件将是这样的三个文件</p>

<ul>
<li><p>infoLogFile = basePath / logger / INFO.20140218.log</p></li>
<li><p>warnLogFile = basePath / logger / WARN.20140218.log</p></li>
<li><p>erroLogFile = basePath / logger / ERRO.20140218.log</p></li>
</ul>


<pre><code>SeasLog::log(SEASLOG_ERROR,'this is a error test by ::log');

SeasLog::debug('this is a {userName} debug',array('{userName}' =&gt; 'neeke'));

SeasLog::info('this is a info log');

SeasLog::notice('this is a notice log');

SeasLog::warning('your {website} was down,please {action} it ASAP!',array('{website}' =&gt; 'github.com','{action}' =&gt; 'rboot'));

SeasLog::error('a error log');

SeasLog::critical('some thing was critical');

SeasLog::alert('yes this is a {messageName}',array('{messageName}' =&gt; 'alertMSG'));

SeasLog::emergency('Just now, the house next door was completely burnt out! {note}',array('{note}' =&gt; 'it`s a joke'));


/*
这些函数同时也接受第3个参数为logger的设置项
注意，当last_logger == 'default'时等同于:
SeasLog::setLogger('test/new/path');
SeasLog::error('test error 3');
如果已经在前文使用过SeasLog::setLogger()函数，第3个参数的log只在此处临时使用，不影响下文。
*/
</code></pre>

<blockquote><p>log格式统一为： {type} | {pid} | {timeStamp} |{dateTime} | {logInfo}</p></blockquote>

<pre><code>error | 23625 | 1406422432.786 | 2014:07:27 08:53:52 | this is a error test by log
debug | 23625 | 1406422432.786 | 2014:07:27 08:53:52 | this is a neeke debug
info | 23625 | 1406422432.787 | 2014:07:27 08:53:52 | this is a info log
notice | 23625 | 1406422432.787 | 2014:07:27 08:53:52 | this is a notice log
warning | 23625 | 1406422432.787 | 2014:07:27 08:53:52 | your github.com was down,please rboot it ASAP!
error | 23625 | 1406422432.787 | 2014:07:27 08:53:52 | a error log
critical | 23625 | 1406422432.787 | 2014:07:27 08:53:52 | some thing was critical
emergency | 23625 | 1406422432.787 | 2014:07:27 08:53:52 | Just now, the house next door was completely burnt out! it is a joke
</code></pre>

<h2>SeasLog Analyzer的使用</h2>

<blockquote><p>快速统计某类型log的count值</p></blockquote>

<p>SeasLog在扩展中使用管道调用shell命令 grep -wc快速地取得count值，并返回值(array || int)给PHP。
```
$countResult_1 = SeasLog::analyzerCount();
$countResult_2 = SeasLog::analyzerCount(SEASLOG_WARNING);
$countResult_3 = SeasLog::analyzerCount(SEASLOG_ERROR,date(&lsquo;Ymd&rsquo;,time()));</p>

<p>var_dump($countResult_1,$countResult_2,$countResult_3);
/*
array(8) {
  [&ldquo;debug&rdquo;]=>
  int(3)
  [&ldquo;info&rdquo;]=>
  int(3)
  [&ldquo;notice&rdquo;]=>
  int(3)
  [&ldquo;warning&rdquo;]=>
  int(3)
  [&ldquo;error&rdquo;]=>
  int(6)
  [&ldquo;critical&rdquo;]=>
  int(3)
  [&ldquo;alert&rdquo;]=>
  int(3)
  [&ldquo;emergency&rdquo;]=>
  int(3)
}</p>

<p>int(7)</p>

<p>int(1)</p>

<p>*/
```</p>

<blockquote><p>获取某类型log列表</p></blockquote>

<p>SeasLog在扩展中使用管道调用shell命令 grep -w快速地取得列表，并返回array给PHP。
```
$detailErrorArray_inAll   = SeasLog::analyzerDetail(SEASLOG_ERROR);
$detailErrorArray_today   = SeasLog::analyzerDetail(SEASLOG_ERROR,date(&lsquo;Ymd&rsquo;,time()));</p>

<p>var_dump($detailErrorArray_inAll,$detailErrorArray_today);</p>

<p>/<em>
SeasLog::analyzerDetail(SEASLOG_ERROR) == SeasLog::analyzerDetail(SEASLOG_ERROR,&lsquo;</em>&rsquo;);
取当前模块下所有level为 SEASLOG_ERROR 的信息列表:
array(6) {
 [0] =>
  string(66) &ldquo;error | 8568 | 1393172042.717 | 2014:02:24 00:14:02 | test error 3 &rdquo;
  [1] =>
  string(66) &ldquo;error | 8594 | 1393172044.104 | 2014:02:24 00:14:04 | test error 3 &rdquo;
  [2] =>
  string(66) &ldquo;error | 8620 | 1393172044.862 | 2014:02:24 00:14:04 | test error 3 &rdquo;
  [3] =>
  string(66) &ldquo;error | 8646 | 1393172045.989 | 2014:02:24 00:14:05 | test error 3 &rdquo;
  [4] =>
  string(66) &ldquo;error | 8672 | 1393172047.882 | 2014:02:24 00:14:07 | test error 3 &rdquo;
  [5] =>
  string(66) &ldquo;error | 8698 | 1393172048.736 | 2014:02:24 00:14:08 | test error 3 &rdquo;
}</p>

<p>SeasLog::analyzerDetail(SEASLOG_ERROR,date(&lsquo;Ymd&rsquo;,time()));
只取得当前模块下，当前一天内,level为SEASLOG_ERROR 的信息列表:
array(2) {
  [0] =>
  string(66) &ldquo;error | 8568 | 1393172042.717 | 2014:02:24 00:14:02 | test error 3 &rdquo;
  [1] =>
  string(66) &ldquo;error | 8594 | 1393172044.104 | 2014:02:24 00:14:04 | test error 3 &rdquo;
}</p>

<p>同理，取当月
$detailErrorArray_mouth = SeasLog::analyzerDetail(SEASLOG_ERROR,date(&lsquo;Ym&rsquo;,time()));</p>

<p>*/
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP无限级分类]]></title>
    <link href="http://ewanreton.github.io/blog/2016/04/29/wu-xian-ji-fen-lei/"/>
    <updated>2016-04-29T09:36:19+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/04/29/wu-xian-ji-fen-lei</id>
    <content type="html"><![CDATA[<blockquote><p>PHP无限级分类主要有两种实现方式，通过递归和全路径实现</p></blockquote>

<!--more-->


<h1>一、递归实现</h1>

<pre><code>在数据库中存储如下格式的表：
</code></pre>

<table>
<thead>
<tr>
<th>ID</th>
<th style="text-align:center;">pid</th>
<th style="text-align:center;">catename</th>
<th style="text-align:center;">cateorder</th>
<th style="text-align:right;">createtime</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td style="text-align:center;">0</td>
<td style="text-align:center;">新闻</td>
<td style="text-align:center;">0</td>
<td style="text-align:right;">0</td>
</tr>
<tr>
<td>2</td>
<td style="text-align:center;">0</td>
<td style="text-align:center;">图片</td>
<td style="text-align:center;">0</td>
<td style="text-align:right;">0</td>
</tr>
<tr>
<td>3</td>
<td style="text-align:center;">1</td>
<td style="text-align:center;">国内新闻</td>
<td style="text-align:center;">0</td>
<td style="text-align:right;">0</td>
</tr>
<tr>
<td>4</td>
<td style="text-align:center;">1</td>
<td style="text-align:center;">国际新闻</td>
<td style="text-align:center;">0</td>
<td style="text-align:right;">0</td>
</tr>
<tr>
<td>5</td>
<td style="text-align:center;">3</td>
<td style="text-align:center;">北京新闻</td>
<td style="text-align:center;">0</td>
<td style="text-align:right;">0</td>
</tr>
<tr>
<td>6</td>
<td style="text-align:center;">4</td>
<td style="text-align:center;">美国新闻</td>
<td style="text-align:center;">0</td>
<td style="text-align:right;">0</td>
</tr>
<tr>
<td>7</td>
<td style="text-align:center;">2</td>
<td style="text-align:center;">美女图片</td>
<td style="text-align:center;">0</td>
<td style="text-align:right;">0</td>
</tr>
<tr>
<td>8</td>
<td style="text-align:center;">2</td>
<td style="text-align:center;">风景图片</td>
<td style="text-align:center;">0</td>
<td style="text-align:right;">0</td>
</tr>
</tbody>
</table>


<pre><code>create table deepcate
(
id int(10) unsigned not null  auto_increment primary key,
pid int(11) unsigned    not null,
catename    varchar(30) not null,
cateorder   int(11) unsigned    default 0,
createtime  int(10) not null
);

insert into deepcate(pid,catename,cateorder,createtime)values(0,'新闻',0,0);
insert into deepcate(pid,catename,cateorder,createtime)values(0,'图片',0,0);
insert into deepcate(pid,catename,cateorder,createtime)values(1,'国内新闻',0,0);
insert into deepcate(pid,catename,cateorder,createtime)values(1,'国际新闻',0,0);
insert into deepcate(pid,catename,cateorder,createtime)values(3,'北京新闻',0,0);
insert into deepcate(pid,catename,cateorder,createtime)values(4,'美国新闻',0,0);
insert into deepcate(pid,catename,cateorder,createtime)values(2,'美女图片',0,0);
insert into deepcate(pid,catename,cateorder,createtime)values(2,'风景图片',0,0);
insert into deepcate(pid,catename,cateorder,createtime)values(7,'日韩明星',0,0);
insert into deepcate(pid,catename,cateorder,createtime)values(9,'日本AV',0,0);

select * from deepcate;
</code></pre>

<blockquote><p>php 代码实现</p></blockquote>

<pre><code>&lt;?php
header("Content-Type:text/html;Charset=UTF-8");
// php无限分类下拉列表的代码实现
include_once('db.inc.php') ;

function getList($pid=0,&amp;$result=array(),$spac=0)
{
    $spac=$spac+2;
    $sql=" SELECT * FROM deepcate WHERE pid=$pid ";
    $res=mysql_query($sql);

    while($row=mysql_fetch_assoc($res)){
        $row['catename']=str_repeat('&amp;nbsp;&amp;nbsp;',$spac).'|--'.$row['catename'];
        $result[]=$row;
        getList($row['id'],$result,$spac);
    }
    return $result;
}

function displayCate($pid=0,$selected=0){
     $rs=getList($pid);
     $str="";
     $str.="&lt;select name='cate'&gt;";
    foreach($rs as $v){
        if($v['id']==$selected){
            $selected="selected";
        }
       $str.="&lt;option {$selected}&gt;";
       $str.= $v['catename'];
       $str.= "&lt;/option&gt;";
    }
    return $str.= "&lt;/select&gt;";
}

echo displayCate();

echo "&lt;hr/&gt;&lt;hr/&gt;";
function getCatePath($cid,&amp;$result){
    $sql="SELECT * FROM deepcate WHERE id=$cid ";
    $rs=mysql_query($sql);
    $row=mysql_fetch_assoc($rs);
    if($row){
        $result[]=$row;
        getCatePath($row['pid'],$result);
    }
    krsort($result);
    return $result;
}


function displayCatePath($cid,$url="deepcate.php?cid="){
    $res=getCatePath($cid,$result);
    $str="";
    foreach($res as $v){
        $str.= "&lt;a href='{$url}{$v['id']}'&gt;{$v['catename']}&lt;/a&gt;&gt;&gt;";
    }return $str;
}

echo displayCatePath(10);
</code></pre>

<h1>二、全路径实现</h1>

<pre><code>use imooc;
create table    likecate
(
id  int(11) not null  auto_increment primary key,
path    varchar(200)    not null,
catename    varchar(30) not null,
cateorder   int(11) not null    default 0,
createtime  int(11) not null
);

insert into likecate(path,catename,cateorder,createtime)values('','手机',0,0);
insert into likecate(path,catename,cateorder,createtime)values('1','功能手机',0,0);
insert into likecate(path,catename,cateorder,createtime)values('1,2','老人手机',0,0);
insert into likecate(path,catename,cateorder,createtime)values('1,2','儿童手机',0,0);
insert into likecate(path,catename,cateorder,createtime)values('1','智能手机',0,0);
insert into likecate(path,catename,cateorder,createtime)values('1,5','andriod手机',0,0);
insert into likecate(path,catename,cateorder,createtime)values('1,5','ios手机',0,0);
insert into likecate(path,catename,cateorder,createtime)values('1,5','winphoto手机',0,0);
insert into likecate(path,catename,cateorder,createtime)values('1,2,4','色盲手机',0,0);
insert into likecate(path,catename,cateorder,createtime)values('1,2,3','大字手机',0,0);

select * from likecate;

select id,catename,path,concat(path,',',id) as fullpath from likecate where 1 order by fullpath asc;

#结果显示如图
+----+--------------+-------+----------+
| id | catename     | path  | fullpath |
+----+--------------+-------+----------+
|  1 | 手机         |       | ,1       |
|  2 | 功能手机     | 1     | 1,2      |
|  3 | 老人手机     | 1,2   | 1,2,3    |
| 10 | 大字手机     | 1,2,3 | 1,2,3,10 |
|  4 | 儿童手机     | 1,2   | 1,2,4    |
|  9 | 色盲手机     | 1,2,4 | 1,2,4,9  |
|  5 | 智能手机     | 1     | 1,5      |
|  6 | andriod手机  | 1,5   | 1,5,6    |
|  7 | ios手机      | 1,5   | 1,5,7    |
|  8 | winphoto手机 | 1,5   | 1,5,8    |
+----+--------------+-------+----------+
</code></pre>

<blockquote><p>php代码实现</p></blockquote>

<pre><code>&lt;?php
header("Content-Type:text/html;Charset=UTF-8");
//递归无限分类原理
include_once ('db.inc.php');

function likecate(){
    $sql="select id,catename,path,concat(path,',',id) as fullpath from likecate where 1 order by fullpath asc";
    $res=mysql_query($sql);
    $result=array();
    while($row=mysql_fetch_assoc($res)){
        $deep=count(explode(',',trim($row['fullpath'],',')));

        $row['catename']=str_repeat('&amp;nbsp;&amp;nbsp;',$deep*4).'|--'.$row['catename'];
        $result[]=$row;
    }
    return $result;
}


$res=likecate();
echo "&lt;select name='cate'&gt;";
foreach($res as $v){
    echo "&lt;option&gt;{$v['catename']}&lt;/option&gt;";
}
echo "&lt;/select&gt;";

echo "&lt;hr/&gt;&lt;hr/&gt;";
function getPathCate($cateid){
    $sql="select *,concat(path,',',id)fullpath from likecate where id=$cateid";
    $res=mysql_query($sql);
    $row=mysql_fetch_assoc($res);
    $ids=$row['fullpath'];
    $sql="select * from likecate where id in($ids) order by id asc";
    $res=mysql_query($sql);
    $result=array();
    while($row=mysql_fetch_assoc($res)){
        $result[]=$row;
    }
    return $result;
}

function displayCatePath($cateid,$link='likecate.php?cid='){
    $res=getPathCate($cateid);
    $str="";
    foreach($res as $v){
        $str.="&lt;a href='{$link}'&gt;{$v['catename']}&lt;/a&gt;&gt;";
    }
    return $str;
}  

echo displayCatePath(4,'likecate.php?p=1&amp;cid=');
</code></pre>
]]></content>
  </entry>
  
</feed>
