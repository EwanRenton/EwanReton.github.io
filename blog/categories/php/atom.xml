<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | Ewan Reton]]></title>
  <link href="http://ewanreton.github.io/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://ewanreton.github.io/"/>
  <updated>2016-05-18T14:55:10+08:00</updated>
  <id>http://ewanreton.github.io/</id>
  <author>
    <name><![CDATA[Ewan Reton]]></name>
    <email><![CDATA[liukedi001@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[php-get-remote-file]]></title>
    <link href="http://ewanreton.github.io/blog/2016/05/18/php-get-remote-file/"/>
    <updated>2016-05-18T14:18:15+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/05/18/php-get-remote-file</id>
    <content type="html"><![CDATA[<blockquote><p>接上次的内容，今天结合代码来分析下PHP获取远程文件的几种方式。</p></blockquote>

<ul>
<li>fopen

<ul>
<li>获取本地文件</li>
<li>获取到的资源绑定到一个流上面</li>
</ul>
</li>
<li>file_get_centents

<ul>
<li>获取一些Get获得的数据，也可以POST，</li>
<li>可以做断点续传</li>
</ul>
</li>
<li>socket</li>
<li>curl

<ul>
<li>可以保存cookie 并且在下一次发送出去</li>
<li>做模拟登陆</li>
</ul>
</li>
</ul>


<h1>fopen</h1>

<pre><code class="php">&lt;?php 
    require_once('common.php');
    echo "&lt;h2&gt;fopen获取文件测试&lt;/h2&gt;";
    /*fopen打开本地文件*/
    $filename="test.html";
    $fp=fopen($filename,"r+");//r+ 只读，+表示如果不存在则创建
    $fc="";
    while(!feof($fp)){
        $fc.=fgets($fp,1024);//获取到的资源绑定到流上。这样来获取流数据
        }
    fclose($fp);
    echo "&lt;h4&gt;输出http_response_header&lt;/h4&gt;";
    dumpout($http_response_header); 
    echo "&lt;h3&gt;本地文件：".$fc."&lt;/h3&gt;";

    /*fopen打开远程url*/
    $filename="http://localhost/Login/02/test.html";
    $fp=fopen($filename,"r");
    echo "&lt;h4&gt;输出stream_get_meta_data&lt;/h4&gt;";
    dumpArr(stream_get_meta_data($fp));
    $fc="";
    while(!feof($fp)){
        $fc=fgets($fp,1024);
        }
    fclose($fp);
    echo "&lt;h4&gt;输出http_response_header&lt;/h4&gt;";
    dumpout($http_response_header);
    echo "&lt;h3&gt;远程url：".$fc."&lt;/h3&gt;";

?&gt;
</code></pre>

<h1>file_get_centents</h1>

<pre><code class="php">&lt;?php 
    require_once('common.php');
    echo "&lt;h2&gt;file_get_contents获取文件测试&lt;/h2&gt;";
    /*file_get_contents打开本地文件*/
    $filename="test.html";
    $fc=file_get_contents($filename);
    echo "&lt;h3&gt;本地文件：".$fc."&lt;/h3&gt;";

    /*fopen打开远程url  get方法*/
    $filename="http://localhost/Login/02/test.php";
    $fc=file_get_contents($filename);
    echo "&lt;h4&gt;输出http_response_header&lt;/h4&gt;";
    dumpout($http_response_header);   
    echo "&lt;h3&gt;get方法获取远程url：".$fc."&lt;/h3&gt;";

    /*fopen打开远程url  post方法*/
    $filename="http://localhost/Login/02/test.php";
    /*构建请求头信息*/
    $post = array ('type' =&gt; '1');
    $content = http_build_query($post);
    $content_length = strlen($content);
    $options = array(
        'http' =&gt; array(
            'method' =&gt; 'POST',
            'header' =&gt;
            "Content-type: application/x-www-form-urlencoded\r\n" .
            "Content-length: $content_length\r\n",
            'content' =&gt; $content
        )
    );
    $fc = file_get_contents($filename, false, stream_context_create($options));
    echo "&lt;h4&gt;输出http_response_header&lt;/h4&gt;";
    dumpout($http_response_header);   
    echo "&lt;h3&gt;post方法获取远程url：".$fc."&lt;/h3&gt;";


?&gt;
</code></pre>

<h1>socket</h1>

<pre><code class="php">&lt;?php 
    require_once('common.php');
    /*Accept: */
    /*  Accept-Language: zh-cn,en-us;q=0.5
        Content-Type: application/x-www-form-urlencoded
        /*模拟浏览器信息*/
        User-Agent: Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; .NET CLR 1.0.3705; .NET CLR 1.1.4322)
        Host: 要发送到的主机地址
        Content-Length: 发送数据的长度
        Pragma: no-cache
        Cache-Control: no-cache
        username=php&amp;password=iask   //post发送的数据
     *
     */


    /*fsocket模拟get提交*/
    echo "&lt;h2&gt;fsocket模拟get提交&lt;/h2&gt;";
    $url="http://localhost/Login/02/test.php?type=1";
    $info = parse_url($url);  
    $fp = fsockopen($info["host"], 80, $errno, $errstr, 3);  
    $head = "GET ".$info['path']."?".$info["query"]." HTTP/1.0\r\n";  
    $head .= "Host: ".$info['host']."\r\n";  
    $head .= "\r\n";  
    $write = fputs($fp, $head);  
    while (!feof($fp)){  
        $line = fgets($fp); 
        echo $line."&lt;br&gt;";  
        }

    /*fsocket模拟post提交*/
    echo "&lt;h2&gt;fsocket模拟post提交&lt;/h2&gt;";
    $query="type=1";
    $info = parse_url($url);  
    $fp = fsockopen($info["host"], 80, $errno, $errstr, 3);  
    $head = "POST ".$info['path']." HTTP/1.0\r\n";  
    $head .= "Host: ".$info['host']."\r\n";  
    $head .= "Referer: http://".$info['host'].$info['path']."\r\n";  
    $head .= "Content-type: application/x-www-form-urlencoded\r\n";  
    $head .= "Content-Length: ".strlen(trim($query))."\r\n";  
    $head .= "\r\n";  
    $head .= trim($query);  
    $write = fputs($fp, $head);  
    while (!feof($fp))  {  
        $line = fgets($fp);  
        echo $line."&lt;br&gt;";  
        }
?&gt;
</code></pre>

<h1>cURL</h1>

<pre><code class="php">&lt;?php 
    require_once('common.php');
    /*curl模拟get提交*/
    echo "&lt;h2&gt;curl模拟get提交&lt;/h2&gt;";
    $url="http://localhost/Login/02/test.php?type=1";

    //初始化
    $ch=curl_init();
    //设置选项，包括URL
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    curl_setopt($ch, CURLOPT_HEADER, 0); 
    //执行并获取HTML文档内容
    $output = curl_exec($ch); 
    echo "&lt;h2&gt;输出curl_getinfo相关信息&lt;/h2&gt;";
    $info = curl_getinfo($ch);
    dumpArr($info);
    //释放curl句柄
    curl_close($ch); 
    //打印获得的数据
    print_r($output);


    echo "&lt;h2&gt;curl模拟post提交&lt;/h2&gt;";
    $url="http://localhost/Login/02/test.php";
    $post_data = array ("type" =&gt; "1");
    $ch = curl_init();
    curl_setopt($ch, CURLOPT_URL, $url);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    // post数据
    curl_setopt($ch, CURLOPT_POST, 1);
    // post的变量
    curl_setopt($ch, CURLOPT_POSTFIELDS, $post_data);
    $output = curl_exec($ch);
    echo "&lt;h2&gt;输出curl_getinfo相关信息&lt;/h2&gt;";
    $info = curl_getinfo($ch);
    dumpArr($info);
    curl_close($ch);
    //打印获得的数据
    print_r($output);
?&gt;
</code></pre>

<hr />

<p>以上几种方式用得较为多的是cURl,因为它可以保存COOKIE的特性，在PHP的网络爬虫中都离不开它。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP爬虫和微信自动投票]]></title>
    <link href="http://ewanreton.github.io/blog/2016/05/17/wechat-auto-vote/"/>
    <updated>2016-05-17T23:38:25+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/05/17/wechat-auto-vote</id>
    <content type="html"><![CDATA[<blockquote><p>今天接触了PHP的模拟登陆和爬虫实战，涉及到了PHP获取远程文件的几种方式，防采集的一些方法，以及微信自动投票实战。</p></blockquote>

<h1>PHP获取远程文件</h1>

<p>PHP获取远程文件主要有以下几种方式：</p>

<ul>
<li>fopen</li>
<li>file_get_centents</li>
<li>socket</li>
<li>curl</li>
</ul>


<p>过几天我们在结合实际代码分析这几种方式</p>

<h1>防采集的一些方法</h1>

<p>防采集的方法有很多，这里主要列出几种比较有效的</p>

<ul>
<li>短时间访问次数限制</li>
<li>ip校验</li>
<li>机器特征校验</li>
<li>复杂加密</li>
<li>混淆代码</li>
</ul>


<h1>微信自动投票工具</h1>

<blockquote><p>这次主要分析这个。</p></blockquote>

<p>首先，我们需要将微信投票界面分析到PC端，并用浏览器F12里的功能抓取到投票的请求地址和返回数据。如下：</p>

<pre class="prettyprint linenums">
http://wx.asplay.cn/index.php?g=Wap&m=Vote&a=index&token=jdfsam1432614294&wecha_id=oQIrdjjmrAZXwKOh3Y6-1HeuwvEc&id=27&sgssz=mp.weixin.qq.com

http://wx.asplay.cn/index.php?
g=Wap&
m=Vote&
a=index&                    //ThinkPHP里面一些参数
token=jdfsam1432614294&     //当前主用户标示
wecha_id=oQIrdjjmrAZXwKOh3Y6-1HeuwvEc&
id=27&      //当前投票ID
sgssz=mp.weixin.qq.com
下面是请求的地址：
http://wx.asplay.cn/index.php?g=Wap&m=Vote&a=add_vote&token=jdfsam1432614294&wecha_id=oQIrdjjArAZYwKOh3Y6-1HeuwvEc
发送的数据：
wecha_id=oQIrdjjArAZYwKOh3Y6-1HeuwvEc&tid=27&chid=53%2C&token=jdfsam1432614294&action=add_vote、
投票成功返回的数据：
{"success":1,"token":"jdfsam1432614294","wecha_id":"oQIrdjjArAZYwKOh3Y6-1HeuwvEc","tid":"27","chid":"53","arrpre":{"53":33.33,"54":0,"55":0,"56":66.67}}
</pre>


<p>基于以上的这些信息，我们就能自己模拟POST的数据，和用户标示了。但是仅仅做到这些是不够的，我们还需要模拟微信的内核。</p>

<pre class="prettyprint linenums">
微信内核的ua：//网上能找到
Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.158888800.95 Safari/537.36 SE 2.X MetaSr 1.0
</pre>


<pre><code class="php ../03/curlajax.class.php">&lt;?php
class curlajax{
    public $cookiejar;
    public $cookiefile;
    public $ua;
    public $debug;

    function __construct(){
        $this-&gt;debug = 0;
        $this-&gt;ua = 'Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/28.0.158888800.95 Safari/537.36 SE 2.X MetaSr 1.0'; //这里模拟微信内核
        $this-&gt;cookiejar = 'cookie.txt';
        $this-&gt;cookiefile = 'cookie.txt';
    }

    /****************************
    *get 请求资源
    *@param string 地址
    *@param string referer
    *@param boolen 是否返回头部
    *@param array 头部附加cookie
    ****************************/
    function httpget($url,$referer='',$withhead=0){
        $ch = curl_init();
        curl_setopt($ch,CURLOPT_URL,$url);
        curl_setopt($ch,CURLOPT_COOKIEJAR,$this-&gt;cookiejar);
        curl_setopt($ch,CURLOPT_COOKIEFILE,$this-&gt;cookiefile);
        curl_setopt($ch,CURLOPT_HEADER,$withhead);
        curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);
        curl_setopt($ch,CURLOPT_FOLLOWLOCATION,1);
        //curl_setopt($ch,CURLOPT_AUTOREFERER,1);
        curl_setopt($ch,CURLOPT_USERAGENT,$this-&gt;ua);
        curl_setopt($ch,CURLOPT_REFERER,$referer);
        $r = curl_exec($ch);
        if($this-&gt;debug){
            echo '&lt;pre&gt;';
            var_dump(curl_getinfo($ch));
        }
        curl_close($ch);
        return $r;
    }

    /****************************
    *post 请求资源
    *@param string 地址
    *@param string referer
    *@param array 提交数据
    *@param boolen 是否返回头部
    ****************************/
    function httppost($url,$referer='',$postdata=array(),$withhead=0){
        $ch = curl_init();
        curl_setopt($ch,CURLOPT_URL,$url);
        curl_setopt($ch,CURLOPT_HEADER,$withhead);
        curl_setopt($ch,CURLOPT_RETURNTRANSFER,1);
        curl_setopt($ch,CURLOPT_FOLLOWLOCATION,1);
        //curl_setopt($ch,CURLOPT_AUTOREFERER,1);
        curl_setopt($ch,CURLOPT_COOKIEJAR,$this-&gt;cookiejar);
        curl_setopt($ch,CURLOPT_COOKIEFILE,$this-&gt;cookiefile);
        curl_setopt($ch,CURLOPT_USERAGENT,$this-&gt;ua);
        curl_setopt($ch,CURLOPT_REFERER,$referer);
        curl_setopt($ch,CURLOPT_POST,1);
        curl_setopt($ch,CURLOPT_POSTFIELDS,$postdata);
        $r = curl_exec($ch);
        if($this-&gt;debug){
            echo '&lt;pre&gt;';
            var_dump(curl_getinfo($ch));
        }
        curl_close($ch);
        return $r;
    }


}
</code></pre>

<p>网上的cURL方法，我们这里有要用到
<figure class='code'><figcaption><span>autoVote.php</span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="o">&amp;</span><span class="nx">lt</span><span class="p">;</span><span class="o">?</span><span class="nx">php</span>
</span><span class='line'><span class="k">require_once</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">ldquo</span><span class="p">;</span><span class="o">../</span><span class="mo">03</span><span class="o">/</span><span class="nx">curlajax</span><span class="o">.</span><span class="nx">class</span><span class="o">.</span><span class="nx">php</span><span class="o">&amp;</span><span class="nx">rdquo</span><span class="p">;);</span>
</span><span class='line'><span class="cp">?&gt;</span><span class="x"></span>
</span><span class='line'><span class="x">&amp;lt;!DOCTYPE html PUBLIC &amp;ldquo;-//W3C//DTD XHTML 1.0 Transitional//EN&amp;rdquo; &amp;ldquo;&lt;a href=&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&lt;/a&gt;&amp;rdquo;&gt;</span>
</span><span class='line'><span class="x">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span>
</span><span class='line'><span class="x">&lt;head&gt;</span>
</span><span class='line'><span class="x">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;</span>
</span><span class='line'><span class="x">&lt;title&gt;微信自动投票工具&lt;/title&gt;</span>
</span><span class='line'><span class="x">&lt;/head&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="x">&lt;p&gt;&lt;body&gt;</span>
</span><span class='line'><span class="x">&amp;lt;?php</span>
</span><span class='line'><span class="x">/&lt;em&gt;模拟POST登录&lt;/em&gt;/</span>
</span><span class='line'><span class="x">echo &amp;ldquo;&lt;h1&gt;这是微信自动投票工具&lt;/h1&gt;&amp;rdquo;;</span>
</span><span class='line'><span class="x">$jkxy = new curlajax();</span>
</span><span class='line'><span class="x">$jkxy-&gt;debug = 0;</span>
</span><span class='line'><span class="x">$jkxy-&gt;cookiejar = dirname(&lt;strong&gt;FILE&lt;/strong&gt;).&amp;lsquo;\cookie1.txt&amp;rsquo;;</span>
</span><span class='line'><span class="x">$jkxy-&gt;cookiefile = dirname(&lt;strong&gt;FILE&lt;/strong&gt;).&amp;lsquo;\cookie1.txt&amp;rsquo;;</span>
</span><span class='line'><span class="x">/&lt;em&gt;模拟提交信息&lt;/em&gt;/</span>
</span><span class='line'><span class="x">$username=&amp;ldquo;oQIrdjj&amp;rdquo;.rand(500,50000).&amp;ldquo;wKOh3Y6-1HeuwvEc&amp;rdquo;;//用随机数来产生不同的用户ID</span>
</span><span class='line'><span class="x">$data = &amp;ldquo;wecha_id=&amp;rdquo;.$username.&amp;ldquo;&amp;amp;tid=27&amp;amp;chid=53%2C&amp;amp;token=jdfsam1432614294&amp;amp;action=add_vote&amp;rdquo;;//模拟不同的用户提交的数据</span>
</span><span class='line'><span class="x">$url = &amp;lsquo;&lt;a href=&quot;http://wx.asplay.cn/index.php?g=Wap&amp;amp;m=Vote&amp;amp;a=add_vote&amp;amp;token=jdfsam1432614294&amp;amp;wecha_id=&quot;&gt;http://wx.asplay.cn/index.php?g=Wap&amp;amp;m=Vote&amp;amp;a=add_vote&amp;amp;token=jdfsam1432614294&amp;amp;wecha_id=&lt;/a&gt;&amp;rsquo;.$username;</span>
</span><span class='line'><span class="x">$r = $jkxy-&gt;httppost($url,$url,$data,0);//获取返回数据&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="x">&lt;p&gt;if(checkstr($r,&amp;lsquo;&amp;ldquo;success&amp;rdquo;:1&amp;rsquo;)==true){ //根据返回的数据判断是否投票成功</span>
</span><span class='line'><span class="x">    echo &amp;ldquo;投票成功&amp;rdquo;;</span>
</span><span class='line'><span class="x">    }</span>
</span><span class='line'><span class="x">else{</span>
</span><span class='line'><span class="x">    echo &amp;ldquo;投票失败&amp;rdquo;;</span>
</span><span class='line'><span class="x">    }</span>
</span><span class='line'><span class="x">    /&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;&lt;strong&gt;</span>
</span><span class='line'><span class="x">    &lt;em&gt;检查$needle中是否含有$findstr</span>
</span><span class='line'><span class="x">    &lt;/em&gt;@param string needle</span>
</span><span class='line'><span class="x">    *@param string findstr</span>
</span><span class='line'><span class="x">    &lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;&lt;/strong&gt;/</span>
</span><span class='line'><span class="x">function checkstr($needle,$findstr){</span>
</span><span class='line'><span class="x">    $tempstr=explode($findstr,$needle);</span>
</span><span class='line'><span class="x">    if($tempstr&gt;1){</span>
</span><span class='line'><span class="x">        return true;</span>
</span><span class='line'><span class="x">        }</span>
</span><span class='line'><span class="x">    else{</span>
</span><span class='line'><span class="x">        return false;</span>
</span><span class='line'><span class="x">        }</span>
</span><span class='line'><span class="x">    }</span>
</span><span class='line'><span class="x">?&gt;</span>
</span><span class='line'><span class="x">&lt;/body&gt;</span>
</span><span class='line'><span class="x">&lt;/html&gt;</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>通过这个实战，感觉突然打开了一扇大门。要仔细研究下爬虫的相关知识了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[QQ登录Demo]]></title>
    <link href="http://ewanreton.github.io/blog/2016/05/15/qq-login/"/>
    <updated>2016-05-15T16:12:15+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/05/15/qq-login</id>
    <content type="html"><![CDATA[<blockquote><p>今天完成了一个QQ登录的小Deom</p></blockquote>

<h1>前置条件</h1>

<ul>
<li>一个QQ号</li>
<li>一台公网通过域名可访问的web服务器</li>
</ul>


<!--more-->


<h1>申请AppID和AppKey</h1>

<p><a href="http://connect.qq.com/">QQ开放平台</a></p>

<p>如果是第一次登录，会跳转到管理中心，应用开发者注册
<img src="http://d.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=b43ea01c0d46f21fcd345e56c61f1a5d/7acb0a46f21fbe0908972df36c600c338644ad08.jpg?referer=6f234af490dda144831e58820b06&amp;x=.jpg" alt="开发者注册" />
注册后悔跳转到管理中心，点击创建应用</p>

<p><img src="http://c.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=7ab420c84634970a4373102aa5f1a0f5/fc1f4134970a304ef778481dd6c8a786c8175cfb.jpg?referer=ebbc6b2a5566d016270eaa189c99&amp;x=.jpg" alt="创建应用" />
回调地址，可以和上面一样，在开发的时候再修改。
<img src="http://f.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=f47f75cf902bd40746c7d3f84bb2ef6c/aa18972bd40735fa1b96a55e99510fb30e2408f7.jpg?referer=8ed677a03e12b31b9e7bf91968ae&amp;x=.jpg" alt="验证" />
将下面这段代码，复制到服务器首页<code>&lt;head&gt;</code>标签中。
<code>html
&lt;meta property="qc:admins" content="43216566776571625476636" /&gt;
</code></p>

<h1>添加测试回调地址</h1>

<p>在QQ开放平台应用详情中，选择信息管理，</p>

<p>在回调地址中添加</p>

<p><img src="http://g.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=2bafae5c4010b912bbc1f6fbf3c68d3e/738b4710b912c8fc25701f2afb039245d7882152.jpg?referer=37adaf2785025aaf8a254afb8f30&amp;x=.jpg" alt="添加回调地址" />
其中的callback.php可以自定义。</p>

<p>记得保存之前需要验证。</p>

<h1>引入官方SDK</h1>

<p><a href="http://wiki.connect.qq.com/">官方SDK</a></p>

<p>找到PHP下载（有能力可以自己手工开发，造车轮。）</p>

<p>放到站点根目录</p>

<h1>SDK参数配置</h1>

<p>访问<code>http://localhost/Connect2.1/install.php</code>
<img src="http://a.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=b155c91931d3d539c53d0fc60abc986d/14ce36d3d539b600424ce650ee50352ac75cb753.jpg?referer=0353883031d12f2e97129a50f131&amp;x=.jpg" alt="参数配置" />
配置成功后,保留API下的文件，其他的都可删除。</p>

<h1>SDK解读</h1>

<p><img src="http://g.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=440c3587322ac65c63056676cbc9c32c/e850352ac65c10382dc82725b5119313b17e89a7.jpg?referer=314909b58235e5ddc93b91eff77d&amp;x=.jpg" alt="" />
<img src="http://b.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=4c5e0d1fa086c9170c03523cf90601f2/d0c8a786c9177f3ebe9d15ea77cf3bc79e3d56a8.jpg?referer=4ebf08d032fae6cd55a39f519266&amp;x=.jpg" alt="" />
<img src="http://h.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=327017c44e540923ae69637ba263a034/ca1349540923dd54e98f4e8fd609b3de9d82485d.jpg?referer=cd4a9bc7be12c8fcede4c2fda833&amp;x=.jpg" alt="" />
<img src="http://a.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=22750c750bf431adb8d2433c7b0ddd92/d1a20cf431adcbefe6cb97e1abaf2edda2cc9f5e.jpg?referer=bd373c299e25bc31724a35a8d934&amp;x=.jpg" alt="" />
<img src="http://f.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=3ede9315d262853596e0d224a0d407fb/4ec2d5628535e5dd429f4c3871c6a7efcf1b62a2.jpg?referer=bc5660e9b63533faaca1a71ece60&amp;x=.jpg" alt="" />
<img src="http://b.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=9a446d86ff1986184547ef817ad65f4e/b151f8198618367af3eb973a29738bd4b21ce5f3.jpg?referer=7862fb405eee3d6d7bd1b3fb4391&amp;x=.jpg" alt="" />
<img src="http://g.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=f77b76cf902bd40746c7d3f84bb2ef6c/aa18972bd40735fa1892a65e99510fb30e2408f3.jpg?referer=8dd274a03e12b31b9e7bf9196892&amp;x=.jpg" alt="" />
<img src="http://a.picphotos.baidu.com/album/s%3D550%3Bq%3D90%3Bc%3Dxiangce%2C100%2C100/sign=4d470c1fa086c9170c03523cf90601f2/d0c8a786c9177f3ebf8414ea77cf3bc79e3d56a1.jpg?referer=4fa609d032fae6cd55a39f51927f&amp;x=.jpg" alt="" /></p>

<h1>将SDK整合到web中</h1>

<p>Connect2.1
放在同级目录下</p>

<pre><code class="php index.php">&lt;?php
require_once "Connect2.1/qqConnectAPI.php";
?&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
      &lt;meta charset="utf-8"&gt;
      &lt;title&gt;&lt;/title&gt;
  &lt;/heda&gt;
    &lt;body&gt;
        &lt;?php if(!isset($_COOKIE['qq_accesstokebn'])||!isset($_COOKIE['qq_openid'])){?&gt;
        &lt;a href="qqlogin.php"&gt;登录QQ&lt;/a&gt;
        &lt;?php }else{?&gt;
          &lt;a href="qqlogout.php"&gt;退出QQ&lt;/a&gt;
          &lt;?php
            $qc = new QC($_COOKIE['qq_accesstokebn'],$_COOKIE['qq_openid']);
            $userinfo =$qc-&gt;get_user_info();
            print_r($userinfo);
                }
          ?&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre>

<pre><code class="php qqlogin.php">&lt;?php
  require_once 'Connect2.1/qqConnectAPI.php';
  //访问QQ页面
  $oauth = new Oauth();
  $oauth-&gt;qq_login();
 ?&gt;
</code></pre>

<pre><code class="php qqlogout.php">&lt;?php
  setcookie('qq_accesstokebn',null);
  setcookie('qq_openid',null);
  header("Location:index.php");
?&gt;
</code></pre>

<pre><code class="php callback.php">&lt;?php
require_once 'Connect2.1/qqConnectAPI.php';
  //echo $_GET['code'];
  //请求accesstoken

$oauth = new Oauth();
$accesstoken = $oauth-&gt;qq_callback();
$openid = $oauth-&gt;get_openid();
setcookie("qq_accesstokebn",$accesstoken,time()+86400);
setcookie("qq_openid",$openid,time()+86400);
header("Location:index.php")
?&gt;
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP-Memcache]]></title>
    <link href="http://ewanreton.github.io/blog/2016/05/14/memcache/"/>
    <updated>2016-05-14T20:08:26+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/05/14/memcache</id>
    <content type="html"><![CDATA[<h1>什么是Memcache</h1>

<blockquote><p>Memcache通过缓存服务器信息的方式来加速服务器处理能力的系统。Memcache分配一块服务器上的内存来缓存一段特定时间之内的最近的查询数据。一旦某个数据被再次请求，那么Memcache就直接从内存中返回这个数据，而不是从数据库中，所以这将会加速查询速度。</p></blockquote>

<!--more-->


<h1>Memcache使用场景</h1>

<ul>
<li>非持久化存储：对数据存储要求不高</li>
<li>分布式存储：不适合单机（对内存消耗很大）</li>
<li>ke/value存储：格式简单，不支持List，Array数据格式

<h1>Memcache服务端的安装</h1></li>
<li>编译安装 Libevent Memcache</li>
<li>依赖管理工具 yum apt-get</li>
<li>Memcache 和Memcached

<ul>
<li>Memcached 是Memcache的升级版本 推荐使用
<code>
$sudo apt-get install memcached
</code></li>
</ul>
</li>
</ul>


<p>安装完Memcache服务端以后，我们需要启动该服务：</p>

<pre><code>memcached -d -m 128 -p 11211 -u root
</code></pre>

<p>使用
<code>
ps -ef |grep memcach
</code>查看是否启动
这里需要说明一下memcached服务的启动参数：</p>

<ul>
<li>-p 监听的端口</li>
<li>-l 连接的IP地址, 默认是本机</li>
<li>-d start 启动memcached服务

<ul>
<li>-d restart 重起memcached服务</li>
<li>-d stop|shutdown 关闭正在运行的memcached服务</li>
<li>-d install 安装memcached服务</li>
<li>-d uninstall 卸载memcached服务</li>
</ul>
</li>
<li>-u 以的身份运行 (仅在以root运行的时候有效)</li>
<li>-m 最大内存使用，单位MB。默认64MB</li>
<li>-M 内存耗尽时返回错误，而不是删除项</li>
<li>-c 最大同时连接数，默认是1024</li>
<li>-f 块大小增长因子，默认是1.25-n 最小分配空间，key+value+flags默认是48</li>
<li>-h 显示帮助

<h1>Memcache客户端的安装</h1></li>
<li>安装Libmemcached</li>
<li>为PHP安装memcached扩展
<code>
$sudo apt-get install php5-memcache
</code>
安装完以后我们需要在php.ini里进行简单的配置,打开/etc/php5/apache2/php.ini文件在末尾添加如下内容：
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='php'><span class='line'><span class="p">[</span><span class="nx">Memcache</span><span class="p">]</span><span class="o">&lt;/</span><span class="nx">li</span><span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="nx">ul</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">;</span> <span class="nx">一个高性能的分布式的内存对象缓存系统，通过在内存里维护一个统一的巨大的hash表，</span>
</span><span class='line'><span class="p">;</span> <span class="nx">它能够用来存储各种格式的数据，包括图像、视频、文件以及数据库检索的结果等。</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">;</span> <span class="nx">是否在遇到错误时透明地向其他服务器进行故障转移。</span>
</span><span class='line'><span class="nx">memcache</span><span class="o">.</span><span class="nx">allow_failover</span> <span class="o">=</span> <span class="nx">On</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">;</span> <span class="nx">接受和发送数据时最多尝试多少个服务器，只在打开memcache</span><span class="o">.</span><span class="nx">allow_failover时有效。memcache</span><span class="o">.</span><span class="nx">max_failover_attempts</span> <span class="o">=</span> <span class="mi">20</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">;</span> <span class="nx">数据将按照此值设定的块大小进行转移。此值越小所需的额外网络传输越多。</span>
</span><span class='line'><span class="p">;</span> <span class="nx">如果发现无法解释的速度降低，可以尝试将此值增加到32768。</span>
</span><span class='line'><span class="nx">memcache</span><span class="o">.</span><span class="nx">chunk_size</span> <span class="o">=</span> <span class="mi">8192</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">;</span> <span class="nx">连接到memcached服务器时使用的默认TCP端口。</span>
</span><span class='line'><span class="nx">memcache</span><span class="o">.</span><span class="nx">default_port</span> <span class="o">=</span> <span class="mi">11211</span><span class="o">&lt;/</span><span class="nx">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">;</span> <span class="nx">控制将key映射到server的策略。默认值”standard”表示使用先前版本的老hash策略。</span>
</span><span class='line'><span class="p">;</span> <span class="nx">设为”consistent”可以允许在连接池中添加</span><span class="o">/</span><span class="nx">删除服务器时不必重新计算key与server之间的映射关系。</span>
</span><span class='line'><span class="p">;</span><span class="nx">memcache</span><span class="o">.</span><span class="nx">hash_strategy</span> <span class="o">=</span> <span class="nx">“standard”</span><span class="p">;</span> <span class="nx">控制将key映射到server的散列函数。默认值”crc32″使用CRC32算法，而”fnv”则表示使用FNV</span><span class="o">-</span><span class="mi">1</span><span class="nx">a算法。</span>
</span><span class='line'><span class="p">;</span> <span class="nx">FNV</span><span class="o">-</span><span class="mi">1</span><span class="nx">a比CRC32速度稍低，但是散列效果更好。</span>
</span><span class='line'><span class="p">;</span><span class="nx">memcache</span><span class="o">.</span><span class="nx">hash_function</span> <span class="o">=</span> <span class="nx">“crc32″</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>保存<code>php.ini</code>,执行<code>service apache2 restart</code>重启Apache。使用<code>php -m |grep memchched</code>查看是否安装成功</p>

<h1>Memcached 常见操作</h1>

<pre><code class="php">&lt;?php
$m = new Memcached();
$array=array(
  array('127.0.0.1',11211),

);
$m-&gt;addServers($array); //添加服务器 添加多条为addServers 一条为 addServer（“127.0.0.1”，11211）；
// // echo "11";
// $info=$m-&gt;getStats();
// print_r($info);
//数据类操作
//add
$m-&gt;add("mkey","mvalue",600);//key value time
$m-&gt;add("mkey","mvalue2",600);//两次赋值不会改变它的值
$m-&gt;replace("mkey","mvalue3",600);//替换
echo $m-&gt;get("mkey");
$m-&gt;set("mkey","mvalue",600);//常用，如果不存在mkey则创建，如果存在则覆盖
$m-&gt;delete("mkey");//删除
$m-&gt;flush();//清空memcache中的所有缓存
$m-&gt;set("num",5,0);
$m-&gt;increment("num",5);//每次刷新num+5
$m-&gt;decrement("num",5);//每次刷新num-5
?&gt;
</code></pre>

<pre><code class="php">&lt;?php
  $m = new Memcached();
  $array=array(
    array("127.0.0.1",11211),
  );
  $m-&gt;addServers($array);
  $data=array(
    "key" =&gt; "value",
    "key2" =&gt;"value2",

  );
  $m-&gt;setMulti($data,0); //一次设置多个值
 $result=  $m-&gt;getMulti(array("key","key2"));//一次获取多个值
 print_r($result);
 $m-&gt;deleteMulti(array("key","key2"));//一次删除多个值
 $m-&gt;getResultCode();//获取上次操作返回值
 $m-&gt;getResultMessage();//获取上次操作的信息
?&gt;
</code></pre>

<p><a href="http://php.net/manual/zh/book.memcached.php">官方说明文档</a></p>

<h1>项目中使用Memcached</h1>

<ul>
<li>即时生成缓存　

<ul>
<li>类似于新闻详情页，第一个人来了生成缓存，第二个人再来直接读缓存</li>
</ul>
</li>
<li>提前生成缓存

<ul>
<li>适合高访问量</li>
</ul>
</li>
<li>永久缓存

<ul>
<li>关于我们 这种基本不变的网页</li>
</ul>
</li>
</ul>


<h1>注意事项</h1>

<ul>
<li>不要在单机模式中使用Memcached</li>
<li>不要在Memcached保存重要数据。掉电会丢失。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PHP性能优化初识]]></title>
    <link href="http://ewanreton.github.io/blog/2016/05/04/php-xing-neng-you-hua/"/>
    <updated>2016-05-04T22:46:21+08:00</updated>
    <id>http://ewanreton.github.io/blog/2016/05/04/php-xing-neng-you-hua</id>
    <content type="html"><![CDATA[<blockquote><p>PHP性能优化</p></blockquote>

<!--more-->


<h1>一、PHP性能优化问题解析</h1>

<p>PHP的性能问题，占整体项目性能问题的比例不足50%，所以在考虑性能优化项目的时候，不要局限于仅优化PHP。</p>

<p>PHP的性能优化问题的解决方向（困难度从容易到简单）</p>

<pre><code>PHP语言级的性能优化
PHP周边问题的性能优化（开发环境等）
PHP语言自身分析、优化（底层C）
</code></pre>

<h2>压力测试工具简介</h2>

<p><strong>Apache Benchmark（ab）</strong></p>

<p>简介</p>

<pre><code>ab是由Apache提供的压力测试软件。安装Apache服务器时会自带该压测软件。
</code></pre>

<p>如何使用</p>

<pre><code>./ab -n1000 -c100 http://www.baidu.com （目标网址）
-n 请求数
-c 并发数
url 目标压测地址
</code></pre>

<p>结果分析</p>

<pre><code>主要看
Request per second 每秒接受的请求数
Time per request   一个请求的耗时
</code></pre>

<h1>二、PHP语言级的优化</h1>

<p><strong>优化点：少写代码，多用PHP自身能力,多使用PHP内置的函数，变量，常量</strong></p>

<p><strong>性能问题：自写代码冗余较多，可读性不佳，并且性能低</strong></p>

<p>为什么性能低？</p>

<pre><code>我们自己写的代码每次需要编译解析成底层语言，每一次请求都会处理一遍开销很大。
</code></pre>

<hr />

<p><strong>PHP内置函数的性能优劣</strong></p>

<p>情况描述：</p>

<pre><code>PHP内置函数之间依然存在着快慢差异
</code></pre>

<p>多去了解PHP内置函数的时间复杂度</p>

<p>举例
<code>php
&lt;?php
    $start=current_time();
    $i=0;
    $arr=range(1,200000);
    while($i&lt;200000){
        ++$i;
        //isset($arr[$i]); //测试结果50多ms
        array_key_exists($i,$arr); //测试结果80多ms
    }
    $end=current_time();
    echo "Lost Time:".number_format($end-$start,3)*1000;
    echo "\n";
    /**
     *返回一个微秒级别的时间戳
     */
    function current_time(){
        list($usec,$sec)=explode("",microtime());
        return ((float)$usce+(float)$sec);
    }
?&gt;
</code>
测试结果说明isset比array_key_exists函数更优化。</p>

<hr />

<p><strong>减少PHP魔法函数的使用</strong></p>

<p>情况描述：</p>

<pre><code>PHP提供的魔法函数性能不佳
</code></pre>

<p>举例
<code>php
&lt;?php
class test{
    private $var="123";
    public function __get($varname){
        return $this-&gt;var;
    }
}
$i=0;
while($i&lt;10000-){
    $i++;
    $test=new test();
    $test-&gt;var;
}//大概80ms
?&gt;
</code></p>

<pre><code class="php">&lt;?php
class test{
    public $var="123";
    //public function __get($varname){
        //return $this-&gt;var;
    //}
}
$i=0;
while($i&lt;100000){
    $i++;
    $test=new test();
    $test-&gt;var;
}//大概50ms
?&gt;
</code></pre>

<p>不使用魔法函数，性能更优化。</p>

<p>PS：</p>

<pre><code>在Linux中可以使用 time php test.php
会输出三个时间，主要关注user为执行时间
</code></pre>

<hr />

<p><strong>产生额外开销的错误抑制符@</strong></p>

<p>情况描述：</p>

<pre><code>@的实际逻辑是在代码开始前结束后增加Opcode 忽略报错。
在@这行前加入Opcode忽略报错，又在这行结束后再加入Opcode，恢复报错。
</code></pre>

<pre><code class="php">&lt;?php
    file_get_contents("XXX");

?&gt;
</code></pre>

<p>用VLD扩展看Opcode代码：</p>

<pre><code>php -dvld.active=1 -dvld.execute=0 at.php //我们只看代码不执行

有三行代码
加上@符号后
有五行代码
</code></pre>

<p>建议不要使用错误抑制符@，
多使用try catch</p>

<hr />

<p><strong>合理使用内存</strong></p>

<p>情况描述：</p>

<pre><code>PHP有内存回收机制保底，但也要小心使用内存。
</code></pre>

<p>利用unset（）及时释放不适用的内存（注：unset（）出现注销不掉的情况）</p>

<hr />

<p><strong>尽量少的使用正则表达式</strong></p>

<p>情况描述：</p>

<pre><code>正则表达式的回溯开销较大。
</code></pre>

<hr />

<p><strong>避免在循环内做运算</strong></p>

<p>情况描述:</p>

<pre><code>循环内的计算式将会被重复计算
</code></pre>

<pre><code class="php">&lt;?php
    $str="Hello World!"
    for($i=0;$i&lt;strlen($str);$i++){//每次循环都会计算这个字符串的长度
        //do something
    }
?&gt;
</code></pre>

<p>改进：</p>

<pre><code class="php">&lt;?php
    $str="Hello World!"
    $strlen=strlen($str)
    for($i=0;$i&lt;$strlen;$i++){
        //do something
    }
?&gt;
</code></pre>

<hr />

<p><strong>减少计算密集型业务</strong></p>

<p>情况描述：</p>

<pre><code>PHP的语言特性决定了PHP不适合密集型运算的场景。
因为PHP是基于C语言的，所以在处理大型运算的时候开销是比C大很多的。
</code></pre>

<p>适合的场景：</p>

<pre><code>衔接Webserver与后端服务，UI呈现。
</code></pre>

<hr />

<p><strong>务必使用带引号字符串做键值</strong></p>

<p>情况描述：</p>

<pre><code>PHP会将没有引号的键值当做常量，产生查找常量的开销。
</code></pre>

<hr />

<h1>三、PHP周边问题的性能优化</h1>

<p><strong>Linux 运行环境</strong></p>

<p><strong>减少文件类的操作</strong></p>

<p>常见PHP场景的开销次序：</p>

<pre><code>读写内存&lt;&lt;读写数据库（数据库有内存缓存）&lt;读写磁盘&lt;读写网络数据（网络延迟）
</code></pre>

<hr />

<p><strong>优化网络请求</strong></p>

<p>可能的问题：
    1. 对方接口的不确定因素
    2. 网络稳定性</p>

<p>优化：</p>

<pre><code>1. 设置超时时间
    连接超时（２００ｍｓ）
    读超时（８００ｍｓ）
    写超时（５００ｍｓ）
２.　串行请求并行化
    使用curl_multi_*() //取决于最长的连接时间所以不推荐
    使用swoole扩展　　
</code></pre>

<hr />

<p><strong>压缩PHP接口输出</strong></p>

<p>使用Gzip压缩即可</p>

<p>优点：</p>

<pre><code>利于我们的数据输出，Client能更快获取数据
</code></pre>

<p>缺点：</p>

<pre><code>产生cpu额外开销
</code></pre>

<p>可以考虑当数据大于多少时再使用压缩来优化。</p>

<hr />

<p><strong>缓存重复计算的内容</strong></p>

<p>什么情况下：</p>

<pre><code>多次请求，内容不变 //使用模板渲染缓存 如smarty 开启caching
</code></pre>

<hr />

<p><strong>重叠时间窗口思想和旁路方案</strong></p>

<pre><code>在几个任务不强依赖前一个任务的输出或者返回时。可以在上一个任务没完成时就执行下一个任务
</code></pre>

<hr />

<h1>四、PHP性能分析</h1>

<p><strong>用XHPorf进行PHP性能问题的具体分析</strong></p>

<p>XHPorf：源自Facebook的PHP性能优化工具
其他工具：</p>

<pre><code>ab -压力测试
vld -opcode 代码分析
</code></pre>

<p><a href="http://www.imooc.com/video/4275">here</a></p>

<h1>五、PHP性能瓶颈究极办法</h1>

<p>Opcode Cache ： PHP扩展APC，memcache</p>

<p>通过PHP扩展代替原PHP代码中高频逻辑</p>

<p>Runtime优化： HHVM</p>
]]></content>
  </entry>
  
</feed>
